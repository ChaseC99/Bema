// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"strconv"
	"sync"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/KA-Challenge-Council/Bema/graph/model"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Announcement() AnnouncementResolver
	Contest() ContestResolver
	Contestant() ContestantResolver
	Entry() EntryResolver
	EntryVote() EntryVoteResolver
	Error() ErrorResolver
	Query() QueryResolver
	Task() TaskResolver
	User() UserResolver
}

type DirectiveRoot struct {
	HasPermission   func(ctx context.Context, obj interface{}, next graphql.Resolver, permission model.Permission, nullType model.NullType, objType *model.ObjectType) (res interface{}, err error)
	IsAuthenticated func(ctx context.Context, obj interface{}, next graphql.Resolver, nullType model.NullType) (res interface{}, err error)
}

type ComplexityRoot struct {
	Announcement struct {
		Author   func(childComplexity int) int
		Content  func(childComplexity int) int
		Created  func(childComplexity int) int
		ID       func(childComplexity int) int
		IsPublic func(childComplexity int) int
		Title    func(childComplexity int) int
	}

	Contest struct {
		Author          func(childComplexity int) int
		BadgeImageURL   func(childComplexity int) int
		BadgeSlug       func(childComplexity int) int
		EndDate         func(childComplexity int) int
		ID              func(childComplexity int) int
		IsCurrent       func(childComplexity int) int
		IsVotingEnabled func(childComplexity int) int
		Name            func(childComplexity int) int
		StartDate       func(childComplexity int) int
		URL             func(childComplexity int) int
		Winners         func(childComplexity int) int
	}

	Contestant struct {
		ContestCount func(childComplexity int) int
		Entries      func(childComplexity int) int
		EntryCount   func(childComplexity int) int
		Kaid         func(childComplexity int) int
		Name         func(childComplexity int) int
	}

	EntriesPerLevel struct {
		Count func(childComplexity int) int
		Level func(childComplexity int) int
	}

	Entry struct {
		Author             func(childComplexity int) int
		AverageScore       func(childComplexity int) int
		Contest            func(childComplexity int) int
		Created            func(childComplexity int) int
		EvaluationCount    func(childComplexity int) int
		Group              func(childComplexity int) int
		Height             func(childComplexity int) int
		ID                 func(childComplexity int) int
		IsDisqualified     func(childComplexity int) int
		IsFlagged          func(childComplexity int) int
		IsSkillLevelLocked func(childComplexity int) int
		IsVotedByUser      func(childComplexity int) int
		IsWinner           func(childComplexity int) int
		JudgeVotes         func(childComplexity int) int
		Kaid               func(childComplexity int) int
		SkillLevel         func(childComplexity int) int
		Title              func(childComplexity int) int
		URL                func(childComplexity int) int
		VoteCount          func(childComplexity int) int
		Votes              func(childComplexity int) int
	}

	EntryVote struct {
		ID     func(childComplexity int) int
		Reason func(childComplexity int) int
		User   func(childComplexity int) int
	}

	Error struct {
		ID               func(childComplexity int) int
		Message          func(childComplexity int) int
		RequestOrigin    func(childComplexity int) int
		RequestReferrer  func(childComplexity int) int
		RequestUserAgent func(childComplexity int) int
		Stack            func(childComplexity int) int
		Timestamp        func(childComplexity int) int
		User             func(childComplexity int) int
	}

	FullUserProfile struct {
		IsAdmin        func(childComplexity int) int
		IsImpersonated func(childComplexity int) int
		LoggedIn       func(childComplexity int) int
		OriginKaid     func(childComplexity int) int
		User           func(childComplexity int) int
	}

	JudgingCriteria struct {
		Description func(childComplexity int) int
		ID          func(childComplexity int) int
		IsActive    func(childComplexity int) int
		Name        func(childComplexity int) int
		SortOrder   func(childComplexity int) int
	}

	JudgingGroup struct {
		ID       func(childComplexity int) int
		IsActive func(childComplexity int) int
		Name     func(childComplexity int) int
	}

	Permissions struct {
		AddEntries            func(childComplexity int) int
		AddUsers              func(childComplexity int) int
		AssignEntryGroups     func(childComplexity int) int
		AssignEvaluatorGroups func(childComplexity int) int
		AssumeUserIdentities  func(childComplexity int) int
		ChangeUserPasswords   func(childComplexity int) int
		DeleteAllEvaluations  func(childComplexity int) int
		DeleteAllTasks        func(childComplexity int) int
		DeleteContests        func(childComplexity int) int
		DeleteEntries         func(childComplexity int) int
		DeleteErrors          func(childComplexity int) int
		DeleteKbContent       func(childComplexity int) int
		EditAllEvaluations    func(childComplexity int) int
		EditAllTasks          func(childComplexity int) int
		EditContests          func(childComplexity int) int
		EditEntries           func(childComplexity int) int
		EditKbContent         func(childComplexity int) int
		EditUserProfiles      func(childComplexity int) int
		JudgeEntries          func(childComplexity int) int
		ManageAnnouncements   func(childComplexity int) int
		ManageJudgingCriteria func(childComplexity int) int
		ManageJudgingGroups   func(childComplexity int) int
		ManageWinners         func(childComplexity int) int
		PublishKbContent      func(childComplexity int) int
		ViewAdminStats        func(childComplexity int) int
		ViewAllEvaluations    func(childComplexity int) int
		ViewAllTasks          func(childComplexity int) int
		ViewAllUsers          func(childComplexity int) int
		ViewErrors            func(childComplexity int) int
		ViewJudgingSettings   func(childComplexity int) int
	}

	Query struct {
		ActiveCriteria        func(childComplexity int) int
		ActiveJudgingGroups   func(childComplexity int) int
		AllCriteria           func(childComplexity int) int
		AllJudgingGroups      func(childComplexity int) int
		Announcements         func(childComplexity int) int
		AvailableTasks        func(childComplexity int) int
		CompletedTasks        func(childComplexity int) int
		Contest               func(childComplexity int, id int) int
		Contestant            func(childComplexity int, kaid string) int
		ContestantSearch      func(childComplexity int, query string) int
		Contests              func(childComplexity int) int
		CurrentContest        func(childComplexity int) int
		CurrentUser           func(childComplexity int) int
		CurrentUserTasks      func(childComplexity int) int
		Entries               func(childComplexity int, contestID int) int
		EntriesByAverageScore func(childComplexity int, contestID int) int
		EntriesPerLevel       func(childComplexity int, contestID int) int
		Entry                 func(childComplexity int, id int) int
		Error                 func(childComplexity int, id int) int
		Errors                func(childComplexity int) int
		FlaggedEntries        func(childComplexity int) int
		InactiveUsers         func(childComplexity int) int
		JudgingGroup          func(childComplexity int, id int) int
		Tasks                 func(childComplexity int) int
		User                  func(childComplexity int, id int) int
		Users                 func(childComplexity int) int
	}

	Task struct {
		AssignedUser func(childComplexity int) int
		DueDate      func(childComplexity int) int
		ID           func(childComplexity int) int
		Status       func(childComplexity int) int
		Title        func(childComplexity int) int
	}

	User struct {
		AccountLocked        func(childComplexity int) int
		AssignedGroup        func(childComplexity int) int
		Email                func(childComplexity int) int
		ID                   func(childComplexity int) int
		IsAdmin              func(childComplexity int) int
		Kaid                 func(childComplexity int) int
		LastLogin            func(childComplexity int) int
		Name                 func(childComplexity int) int
		Nickname             func(childComplexity int) int
		NotificationsEnabled func(childComplexity int) int
		Permissions          func(childComplexity int) int
		TermEnd              func(childComplexity int) int
		TermStart            func(childComplexity int) int
		Username             func(childComplexity int) int
	}
}

type AnnouncementResolver interface {
	Author(ctx context.Context, obj *model.Announcement) (*model.User, error)
}
type ContestResolver interface {
	Author(ctx context.Context, obj *model.Contest) (*string, error)

	IsVotingEnabled(ctx context.Context, obj *model.Contest) (*bool, error)
	Winners(ctx context.Context, obj *model.Contest) ([]*model.Entry, error)
}
type ContestantResolver interface {
	Entries(ctx context.Context, obj *model.Contestant) ([]*model.Entry, error)
	EntryCount(ctx context.Context, obj *model.Contestant) (int, error)
	ContestCount(ctx context.Context, obj *model.Contestant) (int, error)
}
type EntryResolver interface {
	Contest(ctx context.Context, obj *model.Entry) (*model.Contest, error)

	Author(ctx context.Context, obj *model.Entry) (*model.Contestant, error)
	SkillLevel(ctx context.Context, obj *model.Entry) (*string, error)

	Group(ctx context.Context, obj *model.Entry) (*model.JudgingGroup, error)
	IsFlagged(ctx context.Context, obj *model.Entry) (*bool, error)
	IsDisqualified(ctx context.Context, obj *model.Entry) (*bool, error)
	IsSkillLevelLocked(ctx context.Context, obj *model.Entry) (*bool, error)
	AverageScore(ctx context.Context, obj *model.Entry) (*float64, error)
	EvaluationCount(ctx context.Context, obj *model.Entry) (*int, error)
	VoteCount(ctx context.Context, obj *model.Entry) (*int, error)
	IsVotedByUser(ctx context.Context, obj *model.Entry) (*bool, error)
	JudgeVotes(ctx context.Context, obj *model.Entry) ([]*model.EntryVote, error)
}
type EntryVoteResolver interface {
	User(ctx context.Context, obj *model.EntryVote) (*model.User, error)
}
type ErrorResolver interface {
	User(ctx context.Context, obj *model.Error) (*model.User, error)
}
type QueryResolver interface {
	Announcements(ctx context.Context) ([]*model.Announcement, error)
	Contestant(ctx context.Context, kaid string) (*model.Contestant, error)
	ContestantSearch(ctx context.Context, query string) ([]*model.Contestant, error)
	Contests(ctx context.Context) ([]*model.Contest, error)
	Contest(ctx context.Context, id int) (*model.Contest, error)
	CurrentContest(ctx context.Context) (*model.Contest, error)
	Entries(ctx context.Context, contestID int) ([]*model.Entry, error)
	Entry(ctx context.Context, id int) (*model.Entry, error)
	FlaggedEntries(ctx context.Context) ([]*model.Entry, error)
	EntriesByAverageScore(ctx context.Context, contestID int) ([]*model.Entry, error)
	EntriesPerLevel(ctx context.Context, contestID int) ([]*model.EntriesPerLevel, error)
	Errors(ctx context.Context) ([]*model.Error, error)
	Error(ctx context.Context, id int) (*model.Error, error)
	AllCriteria(ctx context.Context) ([]*model.JudgingCriteria, error)
	ActiveCriteria(ctx context.Context) ([]*model.JudgingCriteria, error)
	AllJudgingGroups(ctx context.Context) ([]*model.JudgingGroup, error)
	ActiveJudgingGroups(ctx context.Context) ([]*model.JudgingGroup, error)
	JudgingGroup(ctx context.Context, id int) (*model.JudgingGroup, error)
	Tasks(ctx context.Context) ([]*model.Task, error)
	CompletedTasks(ctx context.Context) ([]*model.Task, error)
	AvailableTasks(ctx context.Context) ([]*model.Task, error)
	CurrentUserTasks(ctx context.Context) ([]*model.Task, error)
	CurrentUser(ctx context.Context) (*model.FullUserProfile, error)
	Users(ctx context.Context) ([]*model.User, error)
	InactiveUsers(ctx context.Context) ([]*model.User, error)
	User(ctx context.Context, id int) (*model.User, error)
}
type TaskResolver interface {
	AssignedUser(ctx context.Context, obj *model.Task) (*model.User, error)
}
type UserResolver interface {
	Name(ctx context.Context, obj *model.User) (*string, error)

	Email(ctx context.Context, obj *model.User) (*string, error)
	AccountLocked(ctx context.Context, obj *model.User) (*bool, error)
	Permissions(ctx context.Context, obj *model.User) (*model.Permissions, error)
	IsAdmin(ctx context.Context, obj *model.User) (*bool, error)
	LastLogin(ctx context.Context, obj *model.User) (*string, error)

	NotificationsEnabled(ctx context.Context, obj *model.User) (*bool, error)
	AssignedGroup(ctx context.Context, obj *model.User) (*model.JudgingGroup, error)
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e}
	_ = ec
	switch typeName + "." + field {

	case "Announcement.author":
		if e.complexity.Announcement.Author == nil {
			break
		}

		return e.complexity.Announcement.Author(childComplexity), true

	case "Announcement.content":
		if e.complexity.Announcement.Content == nil {
			break
		}

		return e.complexity.Announcement.Content(childComplexity), true

	case "Announcement.created":
		if e.complexity.Announcement.Created == nil {
			break
		}

		return e.complexity.Announcement.Created(childComplexity), true

	case "Announcement.id":
		if e.complexity.Announcement.ID == nil {
			break
		}

		return e.complexity.Announcement.ID(childComplexity), true

	case "Announcement.isPublic":
		if e.complexity.Announcement.IsPublic == nil {
			break
		}

		return e.complexity.Announcement.IsPublic(childComplexity), true

	case "Announcement.title":
		if e.complexity.Announcement.Title == nil {
			break
		}

		return e.complexity.Announcement.Title(childComplexity), true

	case "Contest.author":
		if e.complexity.Contest.Author == nil {
			break
		}

		return e.complexity.Contest.Author(childComplexity), true

	case "Contest.badgeImageUrl":
		if e.complexity.Contest.BadgeImageURL == nil {
			break
		}

		return e.complexity.Contest.BadgeImageURL(childComplexity), true

	case "Contest.badgeSlug":
		if e.complexity.Contest.BadgeSlug == nil {
			break
		}

		return e.complexity.Contest.BadgeSlug(childComplexity), true

	case "Contest.endDate":
		if e.complexity.Contest.EndDate == nil {
			break
		}

		return e.complexity.Contest.EndDate(childComplexity), true

	case "Contest.id":
		if e.complexity.Contest.ID == nil {
			break
		}

		return e.complexity.Contest.ID(childComplexity), true

	case "Contest.isCurrent":
		if e.complexity.Contest.IsCurrent == nil {
			break
		}

		return e.complexity.Contest.IsCurrent(childComplexity), true

	case "Contest.isVotingEnabled":
		if e.complexity.Contest.IsVotingEnabled == nil {
			break
		}

		return e.complexity.Contest.IsVotingEnabled(childComplexity), true

	case "Contest.name":
		if e.complexity.Contest.Name == nil {
			break
		}

		return e.complexity.Contest.Name(childComplexity), true

	case "Contest.startDate":
		if e.complexity.Contest.StartDate == nil {
			break
		}

		return e.complexity.Contest.StartDate(childComplexity), true

	case "Contest.url":
		if e.complexity.Contest.URL == nil {
			break
		}

		return e.complexity.Contest.URL(childComplexity), true

	case "Contest.winners":
		if e.complexity.Contest.Winners == nil {
			break
		}

		return e.complexity.Contest.Winners(childComplexity), true

	case "Contestant.contestCount":
		if e.complexity.Contestant.ContestCount == nil {
			break
		}

		return e.complexity.Contestant.ContestCount(childComplexity), true

	case "Contestant.entries":
		if e.complexity.Contestant.Entries == nil {
			break
		}

		return e.complexity.Contestant.Entries(childComplexity), true

	case "Contestant.entryCount":
		if e.complexity.Contestant.EntryCount == nil {
			break
		}

		return e.complexity.Contestant.EntryCount(childComplexity), true

	case "Contestant.kaid":
		if e.complexity.Contestant.Kaid == nil {
			break
		}

		return e.complexity.Contestant.Kaid(childComplexity), true

	case "Contestant.name":
		if e.complexity.Contestant.Name == nil {
			break
		}

		return e.complexity.Contestant.Name(childComplexity), true

	case "EntriesPerLevel.count":
		if e.complexity.EntriesPerLevel.Count == nil {
			break
		}

		return e.complexity.EntriesPerLevel.Count(childComplexity), true

	case "EntriesPerLevel.level":
		if e.complexity.EntriesPerLevel.Level == nil {
			break
		}

		return e.complexity.EntriesPerLevel.Level(childComplexity), true

	case "Entry.author":
		if e.complexity.Entry.Author == nil {
			break
		}

		return e.complexity.Entry.Author(childComplexity), true

	case "Entry.averageScore":
		if e.complexity.Entry.AverageScore == nil {
			break
		}

		return e.complexity.Entry.AverageScore(childComplexity), true

	case "Entry.contest":
		if e.complexity.Entry.Contest == nil {
			break
		}

		return e.complexity.Entry.Contest(childComplexity), true

	case "Entry.created":
		if e.complexity.Entry.Created == nil {
			break
		}

		return e.complexity.Entry.Created(childComplexity), true

	case "Entry.evaluationCount":
		if e.complexity.Entry.EvaluationCount == nil {
			break
		}

		return e.complexity.Entry.EvaluationCount(childComplexity), true

	case "Entry.group":
		if e.complexity.Entry.Group == nil {
			break
		}

		return e.complexity.Entry.Group(childComplexity), true

	case "Entry.height":
		if e.complexity.Entry.Height == nil {
			break
		}

		return e.complexity.Entry.Height(childComplexity), true

	case "Entry.id":
		if e.complexity.Entry.ID == nil {
			break
		}

		return e.complexity.Entry.ID(childComplexity), true

	case "Entry.isDisqualified":
		if e.complexity.Entry.IsDisqualified == nil {
			break
		}

		return e.complexity.Entry.IsDisqualified(childComplexity), true

	case "Entry.isFlagged":
		if e.complexity.Entry.IsFlagged == nil {
			break
		}

		return e.complexity.Entry.IsFlagged(childComplexity), true

	case "Entry.isSkillLevelLocked":
		if e.complexity.Entry.IsSkillLevelLocked == nil {
			break
		}

		return e.complexity.Entry.IsSkillLevelLocked(childComplexity), true

	case "Entry.isVotedByUser":
		if e.complexity.Entry.IsVotedByUser == nil {
			break
		}

		return e.complexity.Entry.IsVotedByUser(childComplexity), true

	case "Entry.isWinner":
		if e.complexity.Entry.IsWinner == nil {
			break
		}

		return e.complexity.Entry.IsWinner(childComplexity), true

	case "Entry.judgeVotes":
		if e.complexity.Entry.JudgeVotes == nil {
			break
		}

		return e.complexity.Entry.JudgeVotes(childComplexity), true

	case "Entry.kaid":
		if e.complexity.Entry.Kaid == nil {
			break
		}

		return e.complexity.Entry.Kaid(childComplexity), true

	case "Entry.skillLevel":
		if e.complexity.Entry.SkillLevel == nil {
			break
		}

		return e.complexity.Entry.SkillLevel(childComplexity), true

	case "Entry.title":
		if e.complexity.Entry.Title == nil {
			break
		}

		return e.complexity.Entry.Title(childComplexity), true

	case "Entry.url":
		if e.complexity.Entry.URL == nil {
			break
		}

		return e.complexity.Entry.URL(childComplexity), true

	case "Entry.voteCount":
		if e.complexity.Entry.VoteCount == nil {
			break
		}

		return e.complexity.Entry.VoteCount(childComplexity), true

	case "Entry.votes":
		if e.complexity.Entry.Votes == nil {
			break
		}

		return e.complexity.Entry.Votes(childComplexity), true

	case "EntryVote.id":
		if e.complexity.EntryVote.ID == nil {
			break
		}

		return e.complexity.EntryVote.ID(childComplexity), true

	case "EntryVote.reason":
		if e.complexity.EntryVote.Reason == nil {
			break
		}

		return e.complexity.EntryVote.Reason(childComplexity), true

	case "EntryVote.user":
		if e.complexity.EntryVote.User == nil {
			break
		}

		return e.complexity.EntryVote.User(childComplexity), true

	case "Error.id":
		if e.complexity.Error.ID == nil {
			break
		}

		return e.complexity.Error.ID(childComplexity), true

	case "Error.message":
		if e.complexity.Error.Message == nil {
			break
		}

		return e.complexity.Error.Message(childComplexity), true

	case "Error.requestOrigin":
		if e.complexity.Error.RequestOrigin == nil {
			break
		}

		return e.complexity.Error.RequestOrigin(childComplexity), true

	case "Error.requestReferrer":
		if e.complexity.Error.RequestReferrer == nil {
			break
		}

		return e.complexity.Error.RequestReferrer(childComplexity), true

	case "Error.requestUserAgent":
		if e.complexity.Error.RequestUserAgent == nil {
			break
		}

		return e.complexity.Error.RequestUserAgent(childComplexity), true

	case "Error.stack":
		if e.complexity.Error.Stack == nil {
			break
		}

		return e.complexity.Error.Stack(childComplexity), true

	case "Error.timestamp":
		if e.complexity.Error.Timestamp == nil {
			break
		}

		return e.complexity.Error.Timestamp(childComplexity), true

	case "Error.user":
		if e.complexity.Error.User == nil {
			break
		}

		return e.complexity.Error.User(childComplexity), true

	case "FullUserProfile.isAdmin":
		if e.complexity.FullUserProfile.IsAdmin == nil {
			break
		}

		return e.complexity.FullUserProfile.IsAdmin(childComplexity), true

	case "FullUserProfile.isImpersonated":
		if e.complexity.FullUserProfile.IsImpersonated == nil {
			break
		}

		return e.complexity.FullUserProfile.IsImpersonated(childComplexity), true

	case "FullUserProfile.loggedIn":
		if e.complexity.FullUserProfile.LoggedIn == nil {
			break
		}

		return e.complexity.FullUserProfile.LoggedIn(childComplexity), true

	case "FullUserProfile.originKaid":
		if e.complexity.FullUserProfile.OriginKaid == nil {
			break
		}

		return e.complexity.FullUserProfile.OriginKaid(childComplexity), true

	case "FullUserProfile.user":
		if e.complexity.FullUserProfile.User == nil {
			break
		}

		return e.complexity.FullUserProfile.User(childComplexity), true

	case "JudgingCriteria.description":
		if e.complexity.JudgingCriteria.Description == nil {
			break
		}

		return e.complexity.JudgingCriteria.Description(childComplexity), true

	case "JudgingCriteria.id":
		if e.complexity.JudgingCriteria.ID == nil {
			break
		}

		return e.complexity.JudgingCriteria.ID(childComplexity), true

	case "JudgingCriteria.isActive":
		if e.complexity.JudgingCriteria.IsActive == nil {
			break
		}

		return e.complexity.JudgingCriteria.IsActive(childComplexity), true

	case "JudgingCriteria.name":
		if e.complexity.JudgingCriteria.Name == nil {
			break
		}

		return e.complexity.JudgingCriteria.Name(childComplexity), true

	case "JudgingCriteria.sortOrder":
		if e.complexity.JudgingCriteria.SortOrder == nil {
			break
		}

		return e.complexity.JudgingCriteria.SortOrder(childComplexity), true

	case "JudgingGroup.id":
		if e.complexity.JudgingGroup.ID == nil {
			break
		}

		return e.complexity.JudgingGroup.ID(childComplexity), true

	case "JudgingGroup.isActive":
		if e.complexity.JudgingGroup.IsActive == nil {
			break
		}

		return e.complexity.JudgingGroup.IsActive(childComplexity), true

	case "JudgingGroup.name":
		if e.complexity.JudgingGroup.Name == nil {
			break
		}

		return e.complexity.JudgingGroup.Name(childComplexity), true

	case "Permissions.add_entries":
		if e.complexity.Permissions.AddEntries == nil {
			break
		}

		return e.complexity.Permissions.AddEntries(childComplexity), true

	case "Permissions.add_users":
		if e.complexity.Permissions.AddUsers == nil {
			break
		}

		return e.complexity.Permissions.AddUsers(childComplexity), true

	case "Permissions.assign_entry_groups":
		if e.complexity.Permissions.AssignEntryGroups == nil {
			break
		}

		return e.complexity.Permissions.AssignEntryGroups(childComplexity), true

	case "Permissions.assign_evaluator_groups":
		if e.complexity.Permissions.AssignEvaluatorGroups == nil {
			break
		}

		return e.complexity.Permissions.AssignEvaluatorGroups(childComplexity), true

	case "Permissions.assume_user_identities":
		if e.complexity.Permissions.AssumeUserIdentities == nil {
			break
		}

		return e.complexity.Permissions.AssumeUserIdentities(childComplexity), true

	case "Permissions.change_user_passwords":
		if e.complexity.Permissions.ChangeUserPasswords == nil {
			break
		}

		return e.complexity.Permissions.ChangeUserPasswords(childComplexity), true

	case "Permissions.delete_all_evaluations":
		if e.complexity.Permissions.DeleteAllEvaluations == nil {
			break
		}

		return e.complexity.Permissions.DeleteAllEvaluations(childComplexity), true

	case "Permissions.delete_all_tasks":
		if e.complexity.Permissions.DeleteAllTasks == nil {
			break
		}

		return e.complexity.Permissions.DeleteAllTasks(childComplexity), true

	case "Permissions.delete_contests":
		if e.complexity.Permissions.DeleteContests == nil {
			break
		}

		return e.complexity.Permissions.DeleteContests(childComplexity), true

	case "Permissions.delete_entries":
		if e.complexity.Permissions.DeleteEntries == nil {
			break
		}

		return e.complexity.Permissions.DeleteEntries(childComplexity), true

	case "Permissions.delete_errors":
		if e.complexity.Permissions.DeleteErrors == nil {
			break
		}

		return e.complexity.Permissions.DeleteErrors(childComplexity), true

	case "Permissions.delete_kb_content":
		if e.complexity.Permissions.DeleteKbContent == nil {
			break
		}

		return e.complexity.Permissions.DeleteKbContent(childComplexity), true

	case "Permissions.edit_all_evaluations":
		if e.complexity.Permissions.EditAllEvaluations == nil {
			break
		}

		return e.complexity.Permissions.EditAllEvaluations(childComplexity), true

	case "Permissions.edit_all_tasks":
		if e.complexity.Permissions.EditAllTasks == nil {
			break
		}

		return e.complexity.Permissions.EditAllTasks(childComplexity), true

	case "Permissions.edit_contests":
		if e.complexity.Permissions.EditContests == nil {
			break
		}

		return e.complexity.Permissions.EditContests(childComplexity), true

	case "Permissions.edit_entries":
		if e.complexity.Permissions.EditEntries == nil {
			break
		}

		return e.complexity.Permissions.EditEntries(childComplexity), true

	case "Permissions.edit_kb_content":
		if e.complexity.Permissions.EditKbContent == nil {
			break
		}

		return e.complexity.Permissions.EditKbContent(childComplexity), true

	case "Permissions.edit_user_profiles":
		if e.complexity.Permissions.EditUserProfiles == nil {
			break
		}

		return e.complexity.Permissions.EditUserProfiles(childComplexity), true

	case "Permissions.judge_entries":
		if e.complexity.Permissions.JudgeEntries == nil {
			break
		}

		return e.complexity.Permissions.JudgeEntries(childComplexity), true

	case "Permissions.manage_announcements":
		if e.complexity.Permissions.ManageAnnouncements == nil {
			break
		}

		return e.complexity.Permissions.ManageAnnouncements(childComplexity), true

	case "Permissions.manage_judging_criteria":
		if e.complexity.Permissions.ManageJudgingCriteria == nil {
			break
		}

		return e.complexity.Permissions.ManageJudgingCriteria(childComplexity), true

	case "Permissions.manage_judging_groups":
		if e.complexity.Permissions.ManageJudgingGroups == nil {
			break
		}

		return e.complexity.Permissions.ManageJudgingGroups(childComplexity), true

	case "Permissions.manage_winners":
		if e.complexity.Permissions.ManageWinners == nil {
			break
		}

		return e.complexity.Permissions.ManageWinners(childComplexity), true

	case "Permissions.publish_kb_content":
		if e.complexity.Permissions.PublishKbContent == nil {
			break
		}

		return e.complexity.Permissions.PublishKbContent(childComplexity), true

	case "Permissions.view_admin_stats":
		if e.complexity.Permissions.ViewAdminStats == nil {
			break
		}

		return e.complexity.Permissions.ViewAdminStats(childComplexity), true

	case "Permissions.view_all_evaluations":
		if e.complexity.Permissions.ViewAllEvaluations == nil {
			break
		}

		return e.complexity.Permissions.ViewAllEvaluations(childComplexity), true

	case "Permissions.view_all_tasks":
		if e.complexity.Permissions.ViewAllTasks == nil {
			break
		}

		return e.complexity.Permissions.ViewAllTasks(childComplexity), true

	case "Permissions.view_all_users":
		if e.complexity.Permissions.ViewAllUsers == nil {
			break
		}

		return e.complexity.Permissions.ViewAllUsers(childComplexity), true

	case "Permissions.view_errors":
		if e.complexity.Permissions.ViewErrors == nil {
			break
		}

		return e.complexity.Permissions.ViewErrors(childComplexity), true

	case "Permissions.view_judging_settings":
		if e.complexity.Permissions.ViewJudgingSettings == nil {
			break
		}

		return e.complexity.Permissions.ViewJudgingSettings(childComplexity), true

	case "Query.activeCriteria":
		if e.complexity.Query.ActiveCriteria == nil {
			break
		}

		return e.complexity.Query.ActiveCriteria(childComplexity), true

	case "Query.activeJudgingGroups":
		if e.complexity.Query.ActiveJudgingGroups == nil {
			break
		}

		return e.complexity.Query.ActiveJudgingGroups(childComplexity), true

	case "Query.allCriteria":
		if e.complexity.Query.AllCriteria == nil {
			break
		}

		return e.complexity.Query.AllCriteria(childComplexity), true

	case "Query.allJudgingGroups":
		if e.complexity.Query.AllJudgingGroups == nil {
			break
		}

		return e.complexity.Query.AllJudgingGroups(childComplexity), true

	case "Query.announcements":
		if e.complexity.Query.Announcements == nil {
			break
		}

		return e.complexity.Query.Announcements(childComplexity), true

	case "Query.availableTasks":
		if e.complexity.Query.AvailableTasks == nil {
			break
		}

		return e.complexity.Query.AvailableTasks(childComplexity), true

	case "Query.completedTasks":
		if e.complexity.Query.CompletedTasks == nil {
			break
		}

		return e.complexity.Query.CompletedTasks(childComplexity), true

	case "Query.contest":
		if e.complexity.Query.Contest == nil {
			break
		}

		args, err := ec.field_Query_contest_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Contest(childComplexity, args["id"].(int)), true

	case "Query.contestant":
		if e.complexity.Query.Contestant == nil {
			break
		}

		args, err := ec.field_Query_contestant_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Contestant(childComplexity, args["kaid"].(string)), true

	case "Query.contestantSearch":
		if e.complexity.Query.ContestantSearch == nil {
			break
		}

		args, err := ec.field_Query_contestantSearch_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ContestantSearch(childComplexity, args["query"].(string)), true

	case "Query.contests":
		if e.complexity.Query.Contests == nil {
			break
		}

		return e.complexity.Query.Contests(childComplexity), true

	case "Query.currentContest":
		if e.complexity.Query.CurrentContest == nil {
			break
		}

		return e.complexity.Query.CurrentContest(childComplexity), true

	case "Query.currentUser":
		if e.complexity.Query.CurrentUser == nil {
			break
		}

		return e.complexity.Query.CurrentUser(childComplexity), true

	case "Query.currentUserTasks":
		if e.complexity.Query.CurrentUserTasks == nil {
			break
		}

		return e.complexity.Query.CurrentUserTasks(childComplexity), true

	case "Query.entries":
		if e.complexity.Query.Entries == nil {
			break
		}

		args, err := ec.field_Query_entries_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Entries(childComplexity, args["contestId"].(int)), true

	case "Query.entriesByAverageScore":
		if e.complexity.Query.EntriesByAverageScore == nil {
			break
		}

		args, err := ec.field_Query_entriesByAverageScore_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.EntriesByAverageScore(childComplexity, args["contestId"].(int)), true

	case "Query.entriesPerLevel":
		if e.complexity.Query.EntriesPerLevel == nil {
			break
		}

		args, err := ec.field_Query_entriesPerLevel_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.EntriesPerLevel(childComplexity, args["contestId"].(int)), true

	case "Query.entry":
		if e.complexity.Query.Entry == nil {
			break
		}

		args, err := ec.field_Query_entry_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Entry(childComplexity, args["id"].(int)), true

	case "Query.error":
		if e.complexity.Query.Error == nil {
			break
		}

		args, err := ec.field_Query_error_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Error(childComplexity, args["id"].(int)), true

	case "Query.errors":
		if e.complexity.Query.Errors == nil {
			break
		}

		return e.complexity.Query.Errors(childComplexity), true

	case "Query.flaggedEntries":
		if e.complexity.Query.FlaggedEntries == nil {
			break
		}

		return e.complexity.Query.FlaggedEntries(childComplexity), true

	case "Query.inactiveUsers":
		if e.complexity.Query.InactiveUsers == nil {
			break
		}

		return e.complexity.Query.InactiveUsers(childComplexity), true

	case "Query.judgingGroup":
		if e.complexity.Query.JudgingGroup == nil {
			break
		}

		args, err := ec.field_Query_judgingGroup_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.JudgingGroup(childComplexity, args["id"].(int)), true

	case "Query.tasks":
		if e.complexity.Query.Tasks == nil {
			break
		}

		return e.complexity.Query.Tasks(childComplexity), true

	case "Query.user":
		if e.complexity.Query.User == nil {
			break
		}

		args, err := ec.field_Query_user_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.User(childComplexity, args["id"].(int)), true

	case "Query.users":
		if e.complexity.Query.Users == nil {
			break
		}

		return e.complexity.Query.Users(childComplexity), true

	case "Task.assignedUser":
		if e.complexity.Task.AssignedUser == nil {
			break
		}

		return e.complexity.Task.AssignedUser(childComplexity), true

	case "Task.dueDate":
		if e.complexity.Task.DueDate == nil {
			break
		}

		return e.complexity.Task.DueDate(childComplexity), true

	case "Task.id":
		if e.complexity.Task.ID == nil {
			break
		}

		return e.complexity.Task.ID(childComplexity), true

	case "Task.status":
		if e.complexity.Task.Status == nil {
			break
		}

		return e.complexity.Task.Status(childComplexity), true

	case "Task.title":
		if e.complexity.Task.Title == nil {
			break
		}

		return e.complexity.Task.Title(childComplexity), true

	case "User.accountLocked":
		if e.complexity.User.AccountLocked == nil {
			break
		}

		return e.complexity.User.AccountLocked(childComplexity), true

	case "User.assignedGroup":
		if e.complexity.User.AssignedGroup == nil {
			break
		}

		return e.complexity.User.AssignedGroup(childComplexity), true

	case "User.email":
		if e.complexity.User.Email == nil {
			break
		}

		return e.complexity.User.Email(childComplexity), true

	case "User.id":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true

	case "User.isAdmin":
		if e.complexity.User.IsAdmin == nil {
			break
		}

		return e.complexity.User.IsAdmin(childComplexity), true

	case "User.kaid":
		if e.complexity.User.Kaid == nil {
			break
		}

		return e.complexity.User.Kaid(childComplexity), true

	case "User.lastLogin":
		if e.complexity.User.LastLogin == nil {
			break
		}

		return e.complexity.User.LastLogin(childComplexity), true

	case "User.name":
		if e.complexity.User.Name == nil {
			break
		}

		return e.complexity.User.Name(childComplexity), true

	case "User.nickname":
		if e.complexity.User.Nickname == nil {
			break
		}

		return e.complexity.User.Nickname(childComplexity), true

	case "User.notificationsEnabled":
		if e.complexity.User.NotificationsEnabled == nil {
			break
		}

		return e.complexity.User.NotificationsEnabled(childComplexity), true

	case "User.permissions":
		if e.complexity.User.Permissions == nil {
			break
		}

		return e.complexity.User.Permissions(childComplexity), true

	case "User.termEnd":
		if e.complexity.User.TermEnd == nil {
			break
		}

		return e.complexity.User.TermEnd(childComplexity), true

	case "User.termStart":
		if e.complexity.User.TermStart == nil {
			break
		}

		return e.complexity.User.TermStart(childComplexity), true

	case "User.username":
		if e.complexity.User.Username == nil {
			break
		}

		return e.complexity.User.Username(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap()
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Query(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "graph/graphql/announcements.graphqls", Input: `extend type Query {
    """
    A list of all announcements
    """
    announcements: [Announcement!]!
}

"""
An announcement message
"""
type Announcement {
    """
    A unique integer ID
    """
    id: ID!

    """
    The author of the announcement
    """
    author: User

    """
    The creation date of the announcement
    """
    created: String!

    """
    The announcement title
    """
    title: String!

    """
    The announcement body
    """
    content: String!

    """
    Indicates whether the announcement is shown to unauthenticated users
    """
    isPublic: Boolean!
}`, BuiltIn: false},
	{Name: "graph/graphql/contestants.graphqls", Input: `extend type Query {
    """
    A single contestant
    """
    contestant(kaid: String!): Contestant

    """
    A list of contestants matching the search query. Can search by display name or KAID.
    """
    contestantSearch(query: String!): [Contestant!]! @isAuthenticated(nullType: EMPTY_CONTESTANT_ARRAY)
}

"""
A Khan Academy user and contest participant
"""
type Contestant {
    """
    The user's unique KAID
    """
    kaid: String!

    """
    The user's most recent display name
    """
    name: String!

    """
    A list of entries submitted by the contestant
    """
    entries: [Entry!] @isAuthenticated(nullType: EMPTY_ENTRY_ARRAY)

    """
    The total number of entries the contestant has submitted
    """
    entryCount: Int!

    """
    The total number of contests the contestant has participated in
    """
    contestCount: Int!
}`, BuiltIn: false},
	{Name: "graph/graphql/contests.graphqls", Input: `extend type Query {
    """
    A list of all contests
    """
    contests: [Contest!]!

    """
    A single contest
    """
    contest(id: ID!): Contest

    """
    The most recent contest
    """
    currentContest: Contest
}

"""
A contest
"""
type Contest {
  """
  A unique integer id of the contest
  """
  id: ID!

  """
  The name of the contest
  """
  name: String!

  """
  The url of the contest program page
  """
  url: String

  """
  The author of the announcement program code. Only visible to contest editors
  """
  author: String @hasPermission(permission: EDIT_CONTESTS, nullType: NULL)

  """
  The url slug of the contest badge
  """
  badgeSlug: String

  """
  A url to the badge image
  """
  badgeImageUrl: String

  """
  Indicates whether the contest is active (accepting entries or being judged). This must be enabled for users to score entries
  """
  isCurrent: Boolean!

  """
  The start date of the contest
  """
  startDate: String

  """
  The end date (deadline) of the contest
  """
  endDate: String

  """
  Indicates whether voting for winners is enabled for the contest. Only shown to evaluators
  """
  isVotingEnabled: Boolean @isAuthenticated(nullType: NULL)

  """
  A list of winning entries
  """
  winners: [Entry!]!
}`, BuiltIn: false},
	{Name: "graph/graphql/directives.graphqls", Input: `"""
Restricts access to a field if the user is not logged in.
nullType - The null value to be returned if the user is not logged in
"""
directive @isAuthenticated(nullType: NullType!) on FIELD_DEFINITION | OBJECT

"""
Restricts access to the field based on a user's permissions. Admins and object owners are allowed to access the field.
permission - The permission to check
nullType - The null value to be returned if the user does not pass the permission check
objType - The type of object the directive is associated with (used to check object ownership)
"""
directive @hasPermission(permission: Permission!, nullType: NullType!, objType: ObjectType) on FIELD_DEFINITION | OBJECT

enum Permission {
    ADD_ENTRIES,
    ADD_USERS,
    ASSIGN_ENTRY_GROUPS,
    ASSIGN_EVALUATOR_GROUPS,
    ASSUME_USER_IDENTITIES,
    CHANGE_USER_PASSWORDS,
    DELETE_ALL_EVALUATIONS,
    DELETE_ALL_TASKS,
    DELETE_CONTESTS,
    DELETE_ENTRIES,
    DELETE_ERRORS,
    DELETE_KB_CONTENT,
    EDIT_ALL_EVALUATIONS,
    EDIT_ALL_TASKS,
    EDIT_CONTESTS,
    EDIT_ENTRIES,
    EDIT_KB_CONTENT,
    EDIT_USER_PROFILES,
    JUDGE_ENTRIES,
    MANAGE_ANNOUNCEMENTS,
    MANAGE_JUDGING_CRITERIA,
    MANAGE_JUDGING_GROUPS,
    MANAGE_WINNERS,
    PUBLISH_KB_CONTENT,
    VIEW_ADMIN_STATS,
    VIEW_ALL_EVALUATIONS,
    VIEW_ALL_TASKS,
    VIEW_ALL_USERS,
    VIEW_ERRORS,
    VIEW_JUDGING_SETTINGS,
}

enum NullType {
    EMPTY_USER_ARRAY
    EMPTY_ERRORS_ARRAY
    EMPTY_STRING
    EMPTY_JUDGING_CRITERIA_ARRAY
    EMPTY_JUDGING_GROUP_ARRAY
    EMPTY_ENTRY_ARRAY
    EMPTY_CONTESTANT_ARRAY
    EMPTY_TASK_ARRAY
    EMPTY_ENTRY_VOTE_ARRAY
    NULL
}

enum ObjectType {
    USER
    TASK
}`, BuiltIn: false},
	{Name: "graph/graphql/entries.graphqls", Input: `extend type Query {
    """
    A list of entries for a given contest
    """
    entries(contestId: ID!): [Entry!]!

    """
    A single entry
    """
    entry(id: ID!): Entry

    """
    A list of flagged entries
    """
    flaggedEntries: [Entry!]! @hasPermission(permission: VIEW_JUDGING_SETTINGS, nullType: EMPTY_ENTRY_ARRAY)

    """
    A list of entries sorted by average score and skill level. If the user is unauthenticated, the entries are sorted by ID instead.
    """
    entriesByAverageScore(contestId: ID!): [Entry!]!

    """
    A breakdown of the number of entries per skill level
    """
    entriesPerLevel(contestId: ID!): [EntriesPerLevel!]!
}

"""
A program submission for a contest
"""
type Entry {
    """
    A unique integer ID
    """
    id: ID!

    """
    The contest for which the entry was submitted
    """
    contest: Contest!

    """
    A URL to the entry program
    """
    url: String!

    """
    The KAID of the entry program
    """
    kaid: String!

    """
    The title of the entry
    """
    title: String!

    """
    The author of the entry
    """
    author: Contestant!

    """
    The skill level assigned to the entry
    """
    skillLevel: String

    """
    The number of votes the entry received on KA
    """
    votes: Int!

    """
    The date the entry program was created
    """
    created: String!

    """
    The height of the entry program canvas
    """
    height: Int!

    """
    Indicates if the entry is a winner of the contest
    """
    isWinner: Boolean!

    """
    The judging group the entry is assigned to
    """
    group: JudgingGroup @isAuthenticated(nullType: NULL)

    """
    Indicates whether the entry has been flagged
    """
    isFlagged: Boolean @isAuthenticated(nullType: NULL)

    """
    Indicates whether the entry has been disqualified
    """
    isDisqualified: Boolean @isAuthenticated(nullType: NULL)

    """
    Indicates whether the skill level has been permanently set for the entry
    """
    isSkillLevelLocked: Boolean @hasPermission(permission: EDIT_ENTRIES, nullType: NULL)

    """
    The average score of the entry
    """
    averageScore: Float @isAuthenticated(nullType: NULL)

    """
    The number of evaluations submitted for the entry
    """
    evaluationCount: Int @isAuthenticated(nullType: NULL)

    """
    The number of judges that voted for this entry
    """
    voteCount: Int @isAuthenticated(nullType: NULL)

    """
    Indicates whether the current user has voted for the entry
    """
    isVotedByUser: Boolean @isAuthenticated(nullType: NULL)

    """
    A list of judge votes for the entry
    """
    judgeVotes: [EntryVote!]! @isAuthenticated(nullType: EMPTY_ENTRY_VOTE_ARRAY)
}

"""
A judge vote submitted for an entry
"""
type EntryVote {
    """
    A unique integer ID
    """
    id: ID!

    """
    The user that voted for the entry
    """
    user: User!

    """
    The reason the user likes the entry
    """
    reason: String!
}

"""
A skill bracket and its respective entry count
"""
type EntriesPerLevel {
    """
    The name of the skill bracket
    """
    level: String!

    """
    The number of entries in the skill bracket
    """
    count: Int!
}`, BuiltIn: false},
	{Name: "graph/graphql/errors.graphqls", Input: `extend type Query {
    """
    A list of all logged errors
    """
    errors: [Error!]! @hasPermission(permission: VIEW_ERRORS, nullType: EMPTY_ERRORS_ARRAY)

    """
    A single logged error
    """
    error(id: ID!): Error @hasPermission(permission: VIEW_ERRORS, nullType: NULL)
}

"""
A logged application error
"""
type Error @hasPermission(permission: VIEW_ERRORS, nullType: NULL) {
    """
    A unique integer id
    """
    id: ID!

    """
    A description of the error
    """
    message: String!

    """
    The call stack of when the error occurred
    """
    stack: String

    """
    The date and time the error occurred
    """
    timestamp: String!

    """
    The origin of the network request associated with the error
    """
    requestOrigin: String

    """
    The referrer of the network request associated with the error
    """
    requestReferrer: String

    """
    The device and browser the user was using
    """
    requestUserAgent: String

    """
    The user that experienced the error, if they were logged in
    """
    user: User
}`, BuiltIn: false},
	{Name: "graph/graphql/judging.graphqls", Input: `extend type Query {
    """
    A list of all judging criteria (both active and inactive)
    """
    allCriteria: [JudgingCriteria!]! @hasPermission(permission: VIEW_JUDGING_SETTINGS, nullType: EMPTY_JUDGING_CRITERIA_ARRAY)

    """
    A list of active judging criteria. Sample data is returned for unauthenticated users.
    """
    activeCriteria: [JudgingCriteria!]!

    """
    A list of all judging groups
    """
    allJudgingGroups: [JudgingGroup!]! @hasPermission(permission: VIEW_JUDGING_SETTINGS, nullType: EMPTY_JUDGING_GROUP_ARRAY)

    """
    A list of all active judging groups
    """
    activeJudgingGroups: [JudgingGroup!]! @isAuthenticated(nullType: EMPTY_JUDGING_GROUP_ARRAY)

    """
    A single judging group
    """
    judgingGroup(id: ID!): JudgingGroup @isAuthenticated(nullType: NULL)
}

"""
Represents a criterium used for scoring entries
"""
type JudgingCriteria {
    """
    A unique integer ID
    """
    id: ID!

    """
    The name of the criteria
    """
    name: String!

    """
    An explanation of how to use the criteria
    """
    description: String!

    """
    Indicates if the criteria should be displayed on the judging page
    """
    isActive: Boolean!

    """
    The order in which the criteria appears
    """
    sortOrder: Int!
}

"""
A group of evaluators that can be assigned entries to judge
"""
type JudgingGroup @isAuthenticated(nullType: NULL) {
    """
    A uniqune integer ID
    """
    id: ID!

    """
    The name of the group
    """
    name: String!

    """
    Indicates whether new entries and users can be assigned to this group
    """
    isActive: Boolean!
}`, BuiltIn: false},
	{Name: "graph/graphql/tasks.graphqls", Input: `extend type Query {
    """
    A list of all incomplete tasks
    """
    tasks: [Task!]! @hasPermission(permission: VIEW_ALL_TASKS, nullType: EMPTY_TASK_ARRAY)

    """
    A list of all completed tasks
    """
    completedTasks: [Task!]! @hasPermission(permission: VIEW_ALL_TASKS, nullType: EMPTY_TASK_ARRAY)

    """
    A list of all tasks available for sign up
    """
    availableTasks: [Task!]! @isAuthenticated(nullType: EMPTY_TASK_ARRAY)

    """
    A list of tasks assigned to the logged in user
    """
    currentUserTasks: [Task!]! @isAuthenticated(nullType: EMPTY_TASK_ARRAY)
}

"""
A single task that can be assigned to and completed by a user
"""
type Task @hasPermission(permission: VIEW_ALL_TASKS, nullType: NULL, objType: TASK) {
    """
    A uniqune integer ID
    """
    id: ID!

    """
    A description of the task
    """
    title: String!

    """
    The user the task is assigned to, or null if unassigned
    """
    assignedUser: User

    """
    The completion status of the task
    """
    status: String!

    """
    The date the task needs to be completed by
    """
    dueDate: String!
}`, BuiltIn: false},
	{Name: "graph/graphql/users.graphqls", Input: `extend type Query {
  """
  The full profile associated with the logged in user
  """
  currentUser: FullUserProfile!

  """
  A list of all active evaluator accounts
  """
  users: [User!]! @isAuthenticated(nullType: EMPTY_USER_ARRAY)

  """
  A list of all inactive evaluator accounts
  """
  inactiveUsers: [User!]! @isAuthenticated(nullType: EMPTY_USER_ARRAY)

  """
  A single user
  """
  user(id: ID!): User
}

"""
The full profile of a logged in user
"""
type FullUserProfile {
  """
  Indicates whether the user is an admin, which allows them to perform all actions and access all data
  """
  isAdmin: Boolean!

  """
  Indicates whether the acting user is being impersonated by an admin user
  """
  isImpersonated: Boolean!

  """
  Indicates whether the actor is logged in
  """
  loggedIn: Boolean!

  """
  The kaid of the actual user, if the current actor is being impersonated
  """
  originKaid: String

  """
  The logged in user
  """
  user: User
}

"""
An evaluator account
"""
type User @isAuthenticated(nullType: NULL) {
  """
  The unique integer id of the user
  """
  id: ID!

  """
  The kaid associated with the user's KA account
  """
  kaid: String!

  """
  The user's real name
  """
  name: String @hasPermission(permission: VIEW_ALL_USERS, nullType: NULL, objType: USER)

  """
  The user's display name
  """
  nickname: String

  """
  The user's username that is used to log in
  """
  username: String

  """
  The user's email address
  """
  email: String @hasPermission(permission: VIEW_ALL_USERS, nullType: NULL, objType: USER)

  """
  Indicates if the account has been deactivated
  """
  accountLocked: Boolean @hasPermission(permission: VIEW_ALL_USERS, nullType: NULL, objType: USER)

  """
  The permission set of the user
  """
  permissions: Permissions @hasPermission(permission: VIEW_ALL_USERS, nullType: NULL, objType: USER)

  """
  Indicates whether the user is an admin, which allows them to perform all actions and access all data
  """
  isAdmin: Boolean @hasPermission(permission: VIEW_ALL_USERS, nullType: NULL, objType: USER)

  """
  The timestamp of the user's last login
  """
  lastLogin: String @hasPermission(permission: VIEW_ALL_USERS, nullType: NULL, objType: USER)

  """
  The start date of the user's term
  """
  termStart: String

  """
  The end date of the user's term
  """
  termEnd: String

  """
  Indicates whether the user has email notifications enabled for new announcements
  """
  notificationsEnabled: Boolean @hasPermission(permission: VIEW_ALL_USERS, nullType: NULL, objType: USER)

  """
  The judging group the user is assigned to
  """
  assignedGroup: JudgingGroup @hasPermission(permission: VIEW_JUDGING_SETTINGS, nullType: NULL, objType: USER)
}

"""
The permissions set, associated with the User type
"""
type Permissions {
  """
  Allows the user to add individual and bulk import entries
  """
  add_entries: Boolean!

  """
  Allows the user to create new user accounts
  """
  add_users: Boolean!

  """
  Allows the user to assign entries to judging groups
  """
  assign_entry_groups: Boolean!

  """
  Allows the user to assign evaluators to judging groups
  """
  assign_evaluator_groups: Boolean!

  """
  Allows the user to impersonate other users
  """
  assume_user_identities: Boolean!

  """
  Allows the user to change the passwords of other users
  """
  change_user_passwords: Boolean!

  """
  Allows the user to delete all evaluations
  """
  delete_all_evaluations: Boolean!

  """
  Allows the user to delete all tasks
  """
  delete_all_tasks: Boolean!

  """
  Allows the user to delete all contests and associated data
  """
  delete_contests: Boolean!

  """
  Allows the user to delete all entries
  """
  delete_entries: Boolean!

  """
  Allows the user to delete all errors
  """
  delete_errors: Boolean!

  """
  Allows the user to delete all KB articles and sections
  """
  delete_kb_content: Boolean!

  """
  Allows the user to edit all evaluations
  """
  edit_all_evaluations: Boolean!

  """
  Allows the user to edit all tasks
  """
  edit_all_tasks: Boolean!

  """
  Allows the user to edit all contests
  """
  edit_contests: Boolean!

  """
  Allows the user to edit all entries
  """
  edit_entries: Boolean!

  """
  Allows the user to edit all KB articles and sections
  """
  edit_kb_content: Boolean!

  """
  Allows the user to edit all user profiles
  """
  edit_user_profiles: Boolean!

  # Allows the user to score entries
  judge_entries: Boolean!

  """
  Allows the user to create, edit, and delete announcements
  """
  manage_announcements: Boolean!

  """
  Allows the user to create, edit, and delete judging criteria
  """
  manage_judging_criteria: Boolean!

  """
  Allows the user to create, edit, and delete judging groups. Needs the assign_evaluator_groups permission to also assign users to groups.
  """
  manage_judging_groups: Boolean!

  """
  Allows the user to add and remove winning entries
  """
  manage_winners: Boolean!

  """
  Allows the user to publish draft KB articles
  """
  publish_kb_content: Boolean!

  """
  Allows the user to view admin stats on the dashboard
  """
  view_admin_stats: Boolean!

  """
  Allows the user to view all evaluations
  """
  view_all_evaluations: Boolean!

  """
  Allows the user to view all tasks
  """
  view_all_tasks: Boolean!

  """
  Allows the user to view all user accounts
  """
  view_all_users: Boolean!

  """
  Allows the user to view all errors
  """
  view_errors: Boolean!

  """
  Allows the user to view all judging settings
  """
  view_judging_settings: Boolean!
}`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) dir_hasPermission_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.Permission
	if tmp, ok := rawArgs["permission"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("permission"))
		arg0, err = ec.unmarshalNPermission2githubcomKAChallengeCouncilBemagraphmodelPermission(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["permission"] = arg0
	var arg1 model.NullType
	if tmp, ok := rawArgs["nullType"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nullType"))
		arg1, err = ec.unmarshalNNullType2githubcomKAChallengeCouncilBemagraphmodelNullType(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["nullType"] = arg1
	var arg2 *model.ObjectType
	if tmp, ok := rawArgs["objType"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("objType"))
		arg2, err = ec.unmarshalOObjectType2githubcomKAChallengeCouncilBemagraphmodelObjectType(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["objType"] = arg2
	return args, nil
}

func (ec *executionContext) dir_isAuthenticated_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.NullType
	if tmp, ok := rawArgs["nullType"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nullType"))
		arg0, err = ec.unmarshalNNullType2githubcomKAChallengeCouncilBemagraphmodelNullType(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["nullType"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_contest_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_contestantSearch_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["query"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("query"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["query"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_contestant_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["kaid"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("kaid"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["kaid"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_entriesByAverageScore_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["contestId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contestId"))
		arg0, err = ec.unmarshalNID2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["contestId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_entriesPerLevel_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["contestId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contestId"))
		arg0, err = ec.unmarshalNID2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["contestId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_entries_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["contestId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contestId"))
		arg0, err = ec.unmarshalNID2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["contestId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_entry_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_error_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_judgingGroup_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_user_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _Announcement_id(ctx context.Context, field graphql.CollectedField, obj *model.Announcement) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Announcement_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Announcement_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Announcement",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Announcement_author(ctx context.Context, field graphql.CollectedField, obj *model.Announcement) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Announcement_author(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Announcement().Author(rctx, obj)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			nullType, err := ec.unmarshalNNullType2githubcomKAChallengeCouncilBemagraphmodelNullType(ctx, "NULL")
			if err != nil {
				return nil, err
			}
			if ec.directives.IsAuthenticated == nil {
				return nil, errors.New("directive isAuthenticated is not implemented")
			}
			return ec.directives.IsAuthenticated(ctx, obj, directive0, nullType)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.User); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/KA-Challenge-Council/Bema/graph/model.User`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.User)
	fc.Result = res
	return ec.marshalOUser2githubcomKAChallengeCouncilBemagraphmodelUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Announcement_author(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Announcement",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "kaid":
				return ec.fieldContext_User_kaid(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "nickname":
				return ec.fieldContext_User_nickname(ctx, field)
			case "username":
				return ec.fieldContext_User_username(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "accountLocked":
				return ec.fieldContext_User_accountLocked(ctx, field)
			case "permissions":
				return ec.fieldContext_User_permissions(ctx, field)
			case "isAdmin":
				return ec.fieldContext_User_isAdmin(ctx, field)
			case "lastLogin":
				return ec.fieldContext_User_lastLogin(ctx, field)
			case "termStart":
				return ec.fieldContext_User_termStart(ctx, field)
			case "termEnd":
				return ec.fieldContext_User_termEnd(ctx, field)
			case "notificationsEnabled":
				return ec.fieldContext_User_notificationsEnabled(ctx, field)
			case "assignedGroup":
				return ec.fieldContext_User_assignedGroup(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Announcement_created(ctx context.Context, field graphql.CollectedField, obj *model.Announcement) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Announcement_created(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Created, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Announcement_created(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Announcement",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Announcement_title(ctx context.Context, field graphql.CollectedField, obj *model.Announcement) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Announcement_title(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Title, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Announcement_title(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Announcement",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Announcement_content(ctx context.Context, field graphql.CollectedField, obj *model.Announcement) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Announcement_content(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Content, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Announcement_content(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Announcement",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Announcement_isPublic(ctx context.Context, field graphql.CollectedField, obj *model.Announcement) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Announcement_isPublic(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsPublic, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Announcement_isPublic(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Announcement",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Contest_id(ctx context.Context, field graphql.CollectedField, obj *model.Contest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Contest_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Contest_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Contest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Contest_name(ctx context.Context, field graphql.CollectedField, obj *model.Contest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Contest_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Contest_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Contest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Contest_url(ctx context.Context, field graphql.CollectedField, obj *model.Contest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Contest_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Contest_url(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Contest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Contest_author(ctx context.Context, field graphql.CollectedField, obj *model.Contest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Contest_author(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Contest().Author(rctx, obj)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			permission, err := ec.unmarshalNPermission2githubcomKAChallengeCouncilBemagraphmodelPermission(ctx, "EDIT_CONTESTS")
			if err != nil {
				return nil, err
			}
			nullType, err := ec.unmarshalNNullType2githubcomKAChallengeCouncilBemagraphmodelNullType(ctx, "NULL")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasPermission == nil {
				return nil, errors.New("directive hasPermission is not implemented")
			}
			return ec.directives.HasPermission(ctx, obj, directive0, permission, nullType, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Contest_author(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Contest",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Contest_badgeSlug(ctx context.Context, field graphql.CollectedField, obj *model.Contest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Contest_badgeSlug(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BadgeSlug, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Contest_badgeSlug(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Contest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Contest_badgeImageUrl(ctx context.Context, field graphql.CollectedField, obj *model.Contest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Contest_badgeImageUrl(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BadgeImageURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Contest_badgeImageUrl(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Contest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Contest_isCurrent(ctx context.Context, field graphql.CollectedField, obj *model.Contest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Contest_isCurrent(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsCurrent, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Contest_isCurrent(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Contest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Contest_startDate(ctx context.Context, field graphql.CollectedField, obj *model.Contest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Contest_startDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Contest_startDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Contest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Contest_endDate(ctx context.Context, field graphql.CollectedField, obj *model.Contest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Contest_endDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Contest_endDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Contest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Contest_isVotingEnabled(ctx context.Context, field graphql.CollectedField, obj *model.Contest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Contest_isVotingEnabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Contest().IsVotingEnabled(rctx, obj)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			nullType, err := ec.unmarshalNNullType2githubcomKAChallengeCouncilBemagraphmodelNullType(ctx, "NULL")
			if err != nil {
				return nil, err
			}
			if ec.directives.IsAuthenticated == nil {
				return nil, errors.New("directive isAuthenticated is not implemented")
			}
			return ec.directives.IsAuthenticated(ctx, obj, directive0, nullType)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Contest_isVotingEnabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Contest",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Contest_winners(ctx context.Context, field graphql.CollectedField, obj *model.Contest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Contest_winners(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Contest().Winners(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Entry)
	fc.Result = res
	return ec.marshalNEntry2githubcomKAChallengeCouncilBemagraphmodelEntry(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Contest_winners(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Contest",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Entry_id(ctx, field)
			case "contest":
				return ec.fieldContext_Entry_contest(ctx, field)
			case "url":
				return ec.fieldContext_Entry_url(ctx, field)
			case "kaid":
				return ec.fieldContext_Entry_kaid(ctx, field)
			case "title":
				return ec.fieldContext_Entry_title(ctx, field)
			case "author":
				return ec.fieldContext_Entry_author(ctx, field)
			case "skillLevel":
				return ec.fieldContext_Entry_skillLevel(ctx, field)
			case "votes":
				return ec.fieldContext_Entry_votes(ctx, field)
			case "created":
				return ec.fieldContext_Entry_created(ctx, field)
			case "height":
				return ec.fieldContext_Entry_height(ctx, field)
			case "isWinner":
				return ec.fieldContext_Entry_isWinner(ctx, field)
			case "group":
				return ec.fieldContext_Entry_group(ctx, field)
			case "isFlagged":
				return ec.fieldContext_Entry_isFlagged(ctx, field)
			case "isDisqualified":
				return ec.fieldContext_Entry_isDisqualified(ctx, field)
			case "isSkillLevelLocked":
				return ec.fieldContext_Entry_isSkillLevelLocked(ctx, field)
			case "averageScore":
				return ec.fieldContext_Entry_averageScore(ctx, field)
			case "evaluationCount":
				return ec.fieldContext_Entry_evaluationCount(ctx, field)
			case "voteCount":
				return ec.fieldContext_Entry_voteCount(ctx, field)
			case "isVotedByUser":
				return ec.fieldContext_Entry_isVotedByUser(ctx, field)
			case "judgeVotes":
				return ec.fieldContext_Entry_judgeVotes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Entry", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Contestant_kaid(ctx context.Context, field graphql.CollectedField, obj *model.Contestant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Contestant_kaid(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kaid, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Contestant_kaid(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Contestant",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Contestant_name(ctx context.Context, field graphql.CollectedField, obj *model.Contestant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Contestant_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Contestant_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Contestant",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Contestant_entries(ctx context.Context, field graphql.CollectedField, obj *model.Contestant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Contestant_entries(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Contestant().Entries(rctx, obj)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			nullType, err := ec.unmarshalNNullType2githubcomKAChallengeCouncilBemagraphmodelNullType(ctx, "EMPTY_ENTRY_ARRAY")
			if err != nil {
				return nil, err
			}
			if ec.directives.IsAuthenticated == nil {
				return nil, errors.New("directive isAuthenticated is not implemented")
			}
			return ec.directives.IsAuthenticated(ctx, obj, directive0, nullType)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.Entry); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/KA-Challenge-Council/Bema/graph/model.Entry`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Entry)
	fc.Result = res
	return ec.marshalOEntry2githubcomKAChallengeCouncilBemagraphmodelEntry(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Contestant_entries(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Contestant",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Entry_id(ctx, field)
			case "contest":
				return ec.fieldContext_Entry_contest(ctx, field)
			case "url":
				return ec.fieldContext_Entry_url(ctx, field)
			case "kaid":
				return ec.fieldContext_Entry_kaid(ctx, field)
			case "title":
				return ec.fieldContext_Entry_title(ctx, field)
			case "author":
				return ec.fieldContext_Entry_author(ctx, field)
			case "skillLevel":
				return ec.fieldContext_Entry_skillLevel(ctx, field)
			case "votes":
				return ec.fieldContext_Entry_votes(ctx, field)
			case "created":
				return ec.fieldContext_Entry_created(ctx, field)
			case "height":
				return ec.fieldContext_Entry_height(ctx, field)
			case "isWinner":
				return ec.fieldContext_Entry_isWinner(ctx, field)
			case "group":
				return ec.fieldContext_Entry_group(ctx, field)
			case "isFlagged":
				return ec.fieldContext_Entry_isFlagged(ctx, field)
			case "isDisqualified":
				return ec.fieldContext_Entry_isDisqualified(ctx, field)
			case "isSkillLevelLocked":
				return ec.fieldContext_Entry_isSkillLevelLocked(ctx, field)
			case "averageScore":
				return ec.fieldContext_Entry_averageScore(ctx, field)
			case "evaluationCount":
				return ec.fieldContext_Entry_evaluationCount(ctx, field)
			case "voteCount":
				return ec.fieldContext_Entry_voteCount(ctx, field)
			case "isVotedByUser":
				return ec.fieldContext_Entry_isVotedByUser(ctx, field)
			case "judgeVotes":
				return ec.fieldContext_Entry_judgeVotes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Entry", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Contestant_entryCount(ctx context.Context, field graphql.CollectedField, obj *model.Contestant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Contestant_entryCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Contestant().EntryCount(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Contestant_entryCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Contestant",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Contestant_contestCount(ctx context.Context, field graphql.CollectedField, obj *model.Contestant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Contestant_contestCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Contestant().ContestCount(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Contestant_contestCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Contestant",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EntriesPerLevel_level(ctx context.Context, field graphql.CollectedField, obj *model.EntriesPerLevel) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EntriesPerLevel_level(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Level, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EntriesPerLevel_level(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EntriesPerLevel",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EntriesPerLevel_count(ctx context.Context, field graphql.CollectedField, obj *model.EntriesPerLevel) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EntriesPerLevel_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EntriesPerLevel_count(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EntriesPerLevel",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Entry_id(ctx context.Context, field graphql.CollectedField, obj *model.Entry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Entry_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Entry_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Entry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Entry_contest(ctx context.Context, field graphql.CollectedField, obj *model.Entry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Entry_contest(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Entry().Contest(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Contest)
	fc.Result = res
	return ec.marshalNContest2githubcomKAChallengeCouncilBemagraphmodelContest(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Entry_contest(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Entry",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Contest_id(ctx, field)
			case "name":
				return ec.fieldContext_Contest_name(ctx, field)
			case "url":
				return ec.fieldContext_Contest_url(ctx, field)
			case "author":
				return ec.fieldContext_Contest_author(ctx, field)
			case "badgeSlug":
				return ec.fieldContext_Contest_badgeSlug(ctx, field)
			case "badgeImageUrl":
				return ec.fieldContext_Contest_badgeImageUrl(ctx, field)
			case "isCurrent":
				return ec.fieldContext_Contest_isCurrent(ctx, field)
			case "startDate":
				return ec.fieldContext_Contest_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_Contest_endDate(ctx, field)
			case "isVotingEnabled":
				return ec.fieldContext_Contest_isVotingEnabled(ctx, field)
			case "winners":
				return ec.fieldContext_Contest_winners(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Contest", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Entry_url(ctx context.Context, field graphql.CollectedField, obj *model.Entry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Entry_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Entry_url(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Entry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Entry_kaid(ctx context.Context, field graphql.CollectedField, obj *model.Entry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Entry_kaid(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kaid, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Entry_kaid(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Entry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Entry_title(ctx context.Context, field graphql.CollectedField, obj *model.Entry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Entry_title(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Title, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Entry_title(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Entry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Entry_author(ctx context.Context, field graphql.CollectedField, obj *model.Entry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Entry_author(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Entry().Author(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Contestant)
	fc.Result = res
	return ec.marshalNContestant2githubcomKAChallengeCouncilBemagraphmodelContestant(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Entry_author(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Entry",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kaid":
				return ec.fieldContext_Contestant_kaid(ctx, field)
			case "name":
				return ec.fieldContext_Contestant_name(ctx, field)
			case "entries":
				return ec.fieldContext_Contestant_entries(ctx, field)
			case "entryCount":
				return ec.fieldContext_Contestant_entryCount(ctx, field)
			case "contestCount":
				return ec.fieldContext_Contestant_contestCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Contestant", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Entry_skillLevel(ctx context.Context, field graphql.CollectedField, obj *model.Entry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Entry_skillLevel(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Entry().SkillLevel(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Entry_skillLevel(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Entry",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Entry_votes(ctx context.Context, field graphql.CollectedField, obj *model.Entry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Entry_votes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Votes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Entry_votes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Entry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Entry_created(ctx context.Context, field graphql.CollectedField, obj *model.Entry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Entry_created(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Created, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Entry_created(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Entry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Entry_height(ctx context.Context, field graphql.CollectedField, obj *model.Entry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Entry_height(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Height, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Entry_height(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Entry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Entry_isWinner(ctx context.Context, field graphql.CollectedField, obj *model.Entry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Entry_isWinner(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsWinner, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Entry_isWinner(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Entry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Entry_group(ctx context.Context, field graphql.CollectedField, obj *model.Entry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Entry_group(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Entry().Group(rctx, obj)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			nullType, err := ec.unmarshalNNullType2githubcomKAChallengeCouncilBemagraphmodelNullType(ctx, "NULL")
			if err != nil {
				return nil, err
			}
			if ec.directives.IsAuthenticated == nil {
				return nil, errors.New("directive isAuthenticated is not implemented")
			}
			return ec.directives.IsAuthenticated(ctx, obj, directive0, nullType)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			nullType, err := ec.unmarshalNNullType2githubcomKAChallengeCouncilBemagraphmodelNullType(ctx, "NULL")
			if err != nil {
				return nil, err
			}
			if ec.directives.IsAuthenticated == nil {
				return nil, errors.New("directive isAuthenticated is not implemented")
			}
			return ec.directives.IsAuthenticated(ctx, obj, directive1, nullType)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.JudgingGroup); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/KA-Challenge-Council/Bema/graph/model.JudgingGroup`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.JudgingGroup)
	fc.Result = res
	return ec.marshalOJudgingGroup2githubcomKAChallengeCouncilBemagraphmodelJudgingGroup(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Entry_group(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Entry",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_JudgingGroup_id(ctx, field)
			case "name":
				return ec.fieldContext_JudgingGroup_name(ctx, field)
			case "isActive":
				return ec.fieldContext_JudgingGroup_isActive(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type JudgingGroup", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Entry_isFlagged(ctx context.Context, field graphql.CollectedField, obj *model.Entry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Entry_isFlagged(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Entry().IsFlagged(rctx, obj)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			nullType, err := ec.unmarshalNNullType2githubcomKAChallengeCouncilBemagraphmodelNullType(ctx, "NULL")
			if err != nil {
				return nil, err
			}
			if ec.directives.IsAuthenticated == nil {
				return nil, errors.New("directive isAuthenticated is not implemented")
			}
			return ec.directives.IsAuthenticated(ctx, obj, directive0, nullType)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Entry_isFlagged(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Entry",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Entry_isDisqualified(ctx context.Context, field graphql.CollectedField, obj *model.Entry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Entry_isDisqualified(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Entry().IsDisqualified(rctx, obj)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			nullType, err := ec.unmarshalNNullType2githubcomKAChallengeCouncilBemagraphmodelNullType(ctx, "NULL")
			if err != nil {
				return nil, err
			}
			if ec.directives.IsAuthenticated == nil {
				return nil, errors.New("directive isAuthenticated is not implemented")
			}
			return ec.directives.IsAuthenticated(ctx, obj, directive0, nullType)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Entry_isDisqualified(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Entry",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Entry_isSkillLevelLocked(ctx context.Context, field graphql.CollectedField, obj *model.Entry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Entry_isSkillLevelLocked(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Entry().IsSkillLevelLocked(rctx, obj)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			permission, err := ec.unmarshalNPermission2githubcomKAChallengeCouncilBemagraphmodelPermission(ctx, "EDIT_ENTRIES")
			if err != nil {
				return nil, err
			}
			nullType, err := ec.unmarshalNNullType2githubcomKAChallengeCouncilBemagraphmodelNullType(ctx, "NULL")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasPermission == nil {
				return nil, errors.New("directive hasPermission is not implemented")
			}
			return ec.directives.HasPermission(ctx, obj, directive0, permission, nullType, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Entry_isSkillLevelLocked(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Entry",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Entry_averageScore(ctx context.Context, field graphql.CollectedField, obj *model.Entry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Entry_averageScore(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Entry().AverageScore(rctx, obj)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			nullType, err := ec.unmarshalNNullType2githubcomKAChallengeCouncilBemagraphmodelNullType(ctx, "NULL")
			if err != nil {
				return nil, err
			}
			if ec.directives.IsAuthenticated == nil {
				return nil, errors.New("directive isAuthenticated is not implemented")
			}
			return ec.directives.IsAuthenticated(ctx, obj, directive0, nullType)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*float64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *float64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Entry_averageScore(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Entry",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Entry_evaluationCount(ctx context.Context, field graphql.CollectedField, obj *model.Entry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Entry_evaluationCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Entry().EvaluationCount(rctx, obj)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			nullType, err := ec.unmarshalNNullType2githubcomKAChallengeCouncilBemagraphmodelNullType(ctx, "NULL")
			if err != nil {
				return nil, err
			}
			if ec.directives.IsAuthenticated == nil {
				return nil, errors.New("directive isAuthenticated is not implemented")
			}
			return ec.directives.IsAuthenticated(ctx, obj, directive0, nullType)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*int); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *int`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Entry_evaluationCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Entry",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Entry_voteCount(ctx context.Context, field graphql.CollectedField, obj *model.Entry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Entry_voteCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Entry().VoteCount(rctx, obj)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			nullType, err := ec.unmarshalNNullType2githubcomKAChallengeCouncilBemagraphmodelNullType(ctx, "NULL")
			if err != nil {
				return nil, err
			}
			if ec.directives.IsAuthenticated == nil {
				return nil, errors.New("directive isAuthenticated is not implemented")
			}
			return ec.directives.IsAuthenticated(ctx, obj, directive0, nullType)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*int); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *int`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Entry_voteCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Entry",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Entry_isVotedByUser(ctx context.Context, field graphql.CollectedField, obj *model.Entry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Entry_isVotedByUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Entry().IsVotedByUser(rctx, obj)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			nullType, err := ec.unmarshalNNullType2githubcomKAChallengeCouncilBemagraphmodelNullType(ctx, "NULL")
			if err != nil {
				return nil, err
			}
			if ec.directives.IsAuthenticated == nil {
				return nil, errors.New("directive isAuthenticated is not implemented")
			}
			return ec.directives.IsAuthenticated(ctx, obj, directive0, nullType)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Entry_isVotedByUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Entry",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Entry_judgeVotes(ctx context.Context, field graphql.CollectedField, obj *model.Entry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Entry_judgeVotes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Entry().JudgeVotes(rctx, obj)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			nullType, err := ec.unmarshalNNullType2githubcomKAChallengeCouncilBemagraphmodelNullType(ctx, "EMPTY_ENTRY_VOTE_ARRAY")
			if err != nil {
				return nil, err
			}
			if ec.directives.IsAuthenticated == nil {
				return nil, errors.New("directive isAuthenticated is not implemented")
			}
			return ec.directives.IsAuthenticated(ctx, obj, directive0, nullType)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.EntryVote); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/KA-Challenge-Council/Bema/graph/model.EntryVote`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.EntryVote)
	fc.Result = res
	return ec.marshalNEntryVote2githubcomKAChallengeCouncilBemagraphmodelEntryVote(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Entry_judgeVotes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Entry",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_EntryVote_id(ctx, field)
			case "user":
				return ec.fieldContext_EntryVote_user(ctx, field)
			case "reason":
				return ec.fieldContext_EntryVote_reason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EntryVote", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _EntryVote_id(ctx context.Context, field graphql.CollectedField, obj *model.EntryVote) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EntryVote_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EntryVote_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EntryVote",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EntryVote_user(ctx context.Context, field graphql.CollectedField, obj *model.EntryVote) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EntryVote_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.EntryVote().User(rctx, obj)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			nullType, err := ec.unmarshalNNullType2githubcomKAChallengeCouncilBemagraphmodelNullType(ctx, "NULL")
			if err != nil {
				return nil, err
			}
			if ec.directives.IsAuthenticated == nil {
				return nil, errors.New("directive isAuthenticated is not implemented")
			}
			return ec.directives.IsAuthenticated(ctx, obj, directive0, nullType)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.User); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/KA-Challenge-Council/Bema/graph/model.User`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.User)
	fc.Result = res
	return ec.marshalNUser2githubcomKAChallengeCouncilBemagraphmodelUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EntryVote_user(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EntryVote",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "kaid":
				return ec.fieldContext_User_kaid(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "nickname":
				return ec.fieldContext_User_nickname(ctx, field)
			case "username":
				return ec.fieldContext_User_username(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "accountLocked":
				return ec.fieldContext_User_accountLocked(ctx, field)
			case "permissions":
				return ec.fieldContext_User_permissions(ctx, field)
			case "isAdmin":
				return ec.fieldContext_User_isAdmin(ctx, field)
			case "lastLogin":
				return ec.fieldContext_User_lastLogin(ctx, field)
			case "termStart":
				return ec.fieldContext_User_termStart(ctx, field)
			case "termEnd":
				return ec.fieldContext_User_termEnd(ctx, field)
			case "notificationsEnabled":
				return ec.fieldContext_User_notificationsEnabled(ctx, field)
			case "assignedGroup":
				return ec.fieldContext_User_assignedGroup(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _EntryVote_reason(ctx context.Context, field graphql.CollectedField, obj *model.EntryVote) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EntryVote_reason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Reason, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EntryVote_reason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EntryVote",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Error_id(ctx context.Context, field graphql.CollectedField, obj *model.Error) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Error_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Error_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Error",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Error_message(ctx context.Context, field graphql.CollectedField, obj *model.Error) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Error_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Error_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Error",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Error_stack(ctx context.Context, field graphql.CollectedField, obj *model.Error) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Error_stack(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Stack, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Error_stack(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Error",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Error_timestamp(ctx context.Context, field graphql.CollectedField, obj *model.Error) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Error_timestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Error_timestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Error",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Error_requestOrigin(ctx context.Context, field graphql.CollectedField, obj *model.Error) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Error_requestOrigin(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RequestOrigin, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Error_requestOrigin(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Error",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Error_requestReferrer(ctx context.Context, field graphql.CollectedField, obj *model.Error) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Error_requestReferrer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RequestReferrer, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Error_requestReferrer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Error",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Error_requestUserAgent(ctx context.Context, field graphql.CollectedField, obj *model.Error) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Error_requestUserAgent(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RequestUserAgent, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Error_requestUserAgent(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Error",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Error_user(ctx context.Context, field graphql.CollectedField, obj *model.Error) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Error_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Error().User(rctx, obj)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			nullType, err := ec.unmarshalNNullType2githubcomKAChallengeCouncilBemagraphmodelNullType(ctx, "NULL")
			if err != nil {
				return nil, err
			}
			if ec.directives.IsAuthenticated == nil {
				return nil, errors.New("directive isAuthenticated is not implemented")
			}
			return ec.directives.IsAuthenticated(ctx, obj, directive0, nullType)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.User); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/KA-Challenge-Council/Bema/graph/model.User`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.User)
	fc.Result = res
	return ec.marshalOUser2githubcomKAChallengeCouncilBemagraphmodelUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Error_user(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Error",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "kaid":
				return ec.fieldContext_User_kaid(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "nickname":
				return ec.fieldContext_User_nickname(ctx, field)
			case "username":
				return ec.fieldContext_User_username(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "accountLocked":
				return ec.fieldContext_User_accountLocked(ctx, field)
			case "permissions":
				return ec.fieldContext_User_permissions(ctx, field)
			case "isAdmin":
				return ec.fieldContext_User_isAdmin(ctx, field)
			case "lastLogin":
				return ec.fieldContext_User_lastLogin(ctx, field)
			case "termStart":
				return ec.fieldContext_User_termStart(ctx, field)
			case "termEnd":
				return ec.fieldContext_User_termEnd(ctx, field)
			case "notificationsEnabled":
				return ec.fieldContext_User_notificationsEnabled(ctx, field)
			case "assignedGroup":
				return ec.fieldContext_User_assignedGroup(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FullUserProfile_isAdmin(ctx context.Context, field graphql.CollectedField, obj *model.FullUserProfile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FullUserProfile_isAdmin(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsAdmin, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FullUserProfile_isAdmin(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FullUserProfile",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FullUserProfile_isImpersonated(ctx context.Context, field graphql.CollectedField, obj *model.FullUserProfile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FullUserProfile_isImpersonated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsImpersonated, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FullUserProfile_isImpersonated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FullUserProfile",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FullUserProfile_loggedIn(ctx context.Context, field graphql.CollectedField, obj *model.FullUserProfile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FullUserProfile_loggedIn(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LoggedIn, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FullUserProfile_loggedIn(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FullUserProfile",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FullUserProfile_originKaid(ctx context.Context, field graphql.CollectedField, obj *model.FullUserProfile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FullUserProfile_originKaid(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OriginKaid, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FullUserProfile_originKaid(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FullUserProfile",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FullUserProfile_user(ctx context.Context, field graphql.CollectedField, obj *model.FullUserProfile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FullUserProfile_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.User, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			nullType, err := ec.unmarshalNNullType2githubcomKAChallengeCouncilBemagraphmodelNullType(ctx, "NULL")
			if err != nil {
				return nil, err
			}
			if ec.directives.IsAuthenticated == nil {
				return nil, errors.New("directive isAuthenticated is not implemented")
			}
			return ec.directives.IsAuthenticated(ctx, obj, directive0, nullType)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.User); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/KA-Challenge-Council/Bema/graph/model.User`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.User)
	fc.Result = res
	return ec.marshalOUser2githubcomKAChallengeCouncilBemagraphmodelUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FullUserProfile_user(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FullUserProfile",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "kaid":
				return ec.fieldContext_User_kaid(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "nickname":
				return ec.fieldContext_User_nickname(ctx, field)
			case "username":
				return ec.fieldContext_User_username(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "accountLocked":
				return ec.fieldContext_User_accountLocked(ctx, field)
			case "permissions":
				return ec.fieldContext_User_permissions(ctx, field)
			case "isAdmin":
				return ec.fieldContext_User_isAdmin(ctx, field)
			case "lastLogin":
				return ec.fieldContext_User_lastLogin(ctx, field)
			case "termStart":
				return ec.fieldContext_User_termStart(ctx, field)
			case "termEnd":
				return ec.fieldContext_User_termEnd(ctx, field)
			case "notificationsEnabled":
				return ec.fieldContext_User_notificationsEnabled(ctx, field)
			case "assignedGroup":
				return ec.fieldContext_User_assignedGroup(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _JudgingCriteria_id(ctx context.Context, field graphql.CollectedField, obj *model.JudgingCriteria) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JudgingCriteria_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JudgingCriteria_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JudgingCriteria",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JudgingCriteria_name(ctx context.Context, field graphql.CollectedField, obj *model.JudgingCriteria) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JudgingCriteria_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JudgingCriteria_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JudgingCriteria",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JudgingCriteria_description(ctx context.Context, field graphql.CollectedField, obj *model.JudgingCriteria) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JudgingCriteria_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JudgingCriteria_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JudgingCriteria",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JudgingCriteria_isActive(ctx context.Context, field graphql.CollectedField, obj *model.JudgingCriteria) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JudgingCriteria_isActive(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsActive, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JudgingCriteria_isActive(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JudgingCriteria",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JudgingCriteria_sortOrder(ctx context.Context, field graphql.CollectedField, obj *model.JudgingCriteria) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JudgingCriteria_sortOrder(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SortOrder, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JudgingCriteria_sortOrder(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JudgingCriteria",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JudgingGroup_id(ctx context.Context, field graphql.CollectedField, obj *model.JudgingGroup) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JudgingGroup_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JudgingGroup_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JudgingGroup",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JudgingGroup_name(ctx context.Context, field graphql.CollectedField, obj *model.JudgingGroup) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JudgingGroup_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JudgingGroup_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JudgingGroup",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JudgingGroup_isActive(ctx context.Context, field graphql.CollectedField, obj *model.JudgingGroup) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JudgingGroup_isActive(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsActive, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JudgingGroup_isActive(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JudgingGroup",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Permissions_add_entries(ctx context.Context, field graphql.CollectedField, obj *model.Permissions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Permissions_add_entries(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AddEntries, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Permissions_add_entries(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Permissions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Permissions_add_users(ctx context.Context, field graphql.CollectedField, obj *model.Permissions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Permissions_add_users(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AddUsers, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Permissions_add_users(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Permissions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Permissions_assign_entry_groups(ctx context.Context, field graphql.CollectedField, obj *model.Permissions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Permissions_assign_entry_groups(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AssignEntryGroups, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Permissions_assign_entry_groups(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Permissions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Permissions_assign_evaluator_groups(ctx context.Context, field graphql.CollectedField, obj *model.Permissions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Permissions_assign_evaluator_groups(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AssignEvaluatorGroups, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Permissions_assign_evaluator_groups(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Permissions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Permissions_assume_user_identities(ctx context.Context, field graphql.CollectedField, obj *model.Permissions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Permissions_assume_user_identities(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AssumeUserIdentities, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Permissions_assume_user_identities(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Permissions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Permissions_change_user_passwords(ctx context.Context, field graphql.CollectedField, obj *model.Permissions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Permissions_change_user_passwords(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChangeUserPasswords, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Permissions_change_user_passwords(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Permissions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Permissions_delete_all_evaluations(ctx context.Context, field graphql.CollectedField, obj *model.Permissions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Permissions_delete_all_evaluations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeleteAllEvaluations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Permissions_delete_all_evaluations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Permissions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Permissions_delete_all_tasks(ctx context.Context, field graphql.CollectedField, obj *model.Permissions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Permissions_delete_all_tasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeleteAllTasks, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Permissions_delete_all_tasks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Permissions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Permissions_delete_contests(ctx context.Context, field graphql.CollectedField, obj *model.Permissions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Permissions_delete_contests(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeleteContests, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Permissions_delete_contests(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Permissions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Permissions_delete_entries(ctx context.Context, field graphql.CollectedField, obj *model.Permissions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Permissions_delete_entries(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeleteEntries, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Permissions_delete_entries(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Permissions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Permissions_delete_errors(ctx context.Context, field graphql.CollectedField, obj *model.Permissions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Permissions_delete_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeleteErrors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Permissions_delete_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Permissions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Permissions_delete_kb_content(ctx context.Context, field graphql.CollectedField, obj *model.Permissions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Permissions_delete_kb_content(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeleteKbContent, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Permissions_delete_kb_content(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Permissions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Permissions_edit_all_evaluations(ctx context.Context, field graphql.CollectedField, obj *model.Permissions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Permissions_edit_all_evaluations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EditAllEvaluations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Permissions_edit_all_evaluations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Permissions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Permissions_edit_all_tasks(ctx context.Context, field graphql.CollectedField, obj *model.Permissions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Permissions_edit_all_tasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EditAllTasks, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Permissions_edit_all_tasks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Permissions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Permissions_edit_contests(ctx context.Context, field graphql.CollectedField, obj *model.Permissions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Permissions_edit_contests(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EditContests, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Permissions_edit_contests(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Permissions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Permissions_edit_entries(ctx context.Context, field graphql.CollectedField, obj *model.Permissions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Permissions_edit_entries(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EditEntries, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Permissions_edit_entries(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Permissions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Permissions_edit_kb_content(ctx context.Context, field graphql.CollectedField, obj *model.Permissions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Permissions_edit_kb_content(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EditKbContent, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Permissions_edit_kb_content(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Permissions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Permissions_edit_user_profiles(ctx context.Context, field graphql.CollectedField, obj *model.Permissions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Permissions_edit_user_profiles(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EditUserProfiles, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Permissions_edit_user_profiles(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Permissions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Permissions_judge_entries(ctx context.Context, field graphql.CollectedField, obj *model.Permissions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Permissions_judge_entries(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.JudgeEntries, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Permissions_judge_entries(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Permissions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Permissions_manage_announcements(ctx context.Context, field graphql.CollectedField, obj *model.Permissions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Permissions_manage_announcements(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ManageAnnouncements, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Permissions_manage_announcements(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Permissions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Permissions_manage_judging_criteria(ctx context.Context, field graphql.CollectedField, obj *model.Permissions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Permissions_manage_judging_criteria(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ManageJudgingCriteria, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Permissions_manage_judging_criteria(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Permissions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Permissions_manage_judging_groups(ctx context.Context, field graphql.CollectedField, obj *model.Permissions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Permissions_manage_judging_groups(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ManageJudgingGroups, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Permissions_manage_judging_groups(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Permissions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Permissions_manage_winners(ctx context.Context, field graphql.CollectedField, obj *model.Permissions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Permissions_manage_winners(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ManageWinners, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Permissions_manage_winners(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Permissions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Permissions_publish_kb_content(ctx context.Context, field graphql.CollectedField, obj *model.Permissions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Permissions_publish_kb_content(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PublishKbContent, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Permissions_publish_kb_content(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Permissions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Permissions_view_admin_stats(ctx context.Context, field graphql.CollectedField, obj *model.Permissions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Permissions_view_admin_stats(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ViewAdminStats, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Permissions_view_admin_stats(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Permissions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Permissions_view_all_evaluations(ctx context.Context, field graphql.CollectedField, obj *model.Permissions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Permissions_view_all_evaluations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ViewAllEvaluations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Permissions_view_all_evaluations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Permissions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Permissions_view_all_tasks(ctx context.Context, field graphql.CollectedField, obj *model.Permissions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Permissions_view_all_tasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ViewAllTasks, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Permissions_view_all_tasks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Permissions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Permissions_view_all_users(ctx context.Context, field graphql.CollectedField, obj *model.Permissions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Permissions_view_all_users(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ViewAllUsers, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Permissions_view_all_users(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Permissions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Permissions_view_errors(ctx context.Context, field graphql.CollectedField, obj *model.Permissions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Permissions_view_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ViewErrors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Permissions_view_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Permissions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Permissions_view_judging_settings(ctx context.Context, field graphql.CollectedField, obj *model.Permissions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Permissions_view_judging_settings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ViewJudgingSettings, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Permissions_view_judging_settings(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Permissions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_announcements(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_announcements(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Announcements(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Announcement)
	fc.Result = res
	return ec.marshalNAnnouncement2githubcomKAChallengeCouncilBemagraphmodelAnnouncement(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_announcements(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Announcement_id(ctx, field)
			case "author":
				return ec.fieldContext_Announcement_author(ctx, field)
			case "created":
				return ec.fieldContext_Announcement_created(ctx, field)
			case "title":
				return ec.fieldContext_Announcement_title(ctx, field)
			case "content":
				return ec.fieldContext_Announcement_content(ctx, field)
			case "isPublic":
				return ec.fieldContext_Announcement_isPublic(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Announcement", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_contestant(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_contestant(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Contestant(rctx, fc.Args["kaid"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Contestant)
	fc.Result = res
	return ec.marshalOContestant2githubcomKAChallengeCouncilBemagraphmodelContestant(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_contestant(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kaid":
				return ec.fieldContext_Contestant_kaid(ctx, field)
			case "name":
				return ec.fieldContext_Contestant_name(ctx, field)
			case "entries":
				return ec.fieldContext_Contestant_entries(ctx, field)
			case "entryCount":
				return ec.fieldContext_Contestant_entryCount(ctx, field)
			case "contestCount":
				return ec.fieldContext_Contestant_contestCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Contestant", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_contestant_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_contestantSearch(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_contestantSearch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ContestantSearch(rctx, fc.Args["query"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			nullType, err := ec.unmarshalNNullType2githubcomKAChallengeCouncilBemagraphmodelNullType(ctx, "EMPTY_CONTESTANT_ARRAY")
			if err != nil {
				return nil, err
			}
			if ec.directives.IsAuthenticated == nil {
				return nil, errors.New("directive isAuthenticated is not implemented")
			}
			return ec.directives.IsAuthenticated(ctx, nil, directive0, nullType)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.Contestant); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/KA-Challenge-Council/Bema/graph/model.Contestant`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Contestant)
	fc.Result = res
	return ec.marshalNContestant2githubcomKAChallengeCouncilBemagraphmodelContestant(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_contestantSearch(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kaid":
				return ec.fieldContext_Contestant_kaid(ctx, field)
			case "name":
				return ec.fieldContext_Contestant_name(ctx, field)
			case "entries":
				return ec.fieldContext_Contestant_entries(ctx, field)
			case "entryCount":
				return ec.fieldContext_Contestant_entryCount(ctx, field)
			case "contestCount":
				return ec.fieldContext_Contestant_contestCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Contestant", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_contestantSearch_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_contests(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_contests(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Contests(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Contest)
	fc.Result = res
	return ec.marshalNContest2githubcomKAChallengeCouncilBemagraphmodelContest(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_contests(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Contest_id(ctx, field)
			case "name":
				return ec.fieldContext_Contest_name(ctx, field)
			case "url":
				return ec.fieldContext_Contest_url(ctx, field)
			case "author":
				return ec.fieldContext_Contest_author(ctx, field)
			case "badgeSlug":
				return ec.fieldContext_Contest_badgeSlug(ctx, field)
			case "badgeImageUrl":
				return ec.fieldContext_Contest_badgeImageUrl(ctx, field)
			case "isCurrent":
				return ec.fieldContext_Contest_isCurrent(ctx, field)
			case "startDate":
				return ec.fieldContext_Contest_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_Contest_endDate(ctx, field)
			case "isVotingEnabled":
				return ec.fieldContext_Contest_isVotingEnabled(ctx, field)
			case "winners":
				return ec.fieldContext_Contest_winners(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Contest", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_contest(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_contest(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Contest(rctx, fc.Args["id"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Contest)
	fc.Result = res
	return ec.marshalOContest2githubcomKAChallengeCouncilBemagraphmodelContest(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_contest(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Contest_id(ctx, field)
			case "name":
				return ec.fieldContext_Contest_name(ctx, field)
			case "url":
				return ec.fieldContext_Contest_url(ctx, field)
			case "author":
				return ec.fieldContext_Contest_author(ctx, field)
			case "badgeSlug":
				return ec.fieldContext_Contest_badgeSlug(ctx, field)
			case "badgeImageUrl":
				return ec.fieldContext_Contest_badgeImageUrl(ctx, field)
			case "isCurrent":
				return ec.fieldContext_Contest_isCurrent(ctx, field)
			case "startDate":
				return ec.fieldContext_Contest_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_Contest_endDate(ctx, field)
			case "isVotingEnabled":
				return ec.fieldContext_Contest_isVotingEnabled(ctx, field)
			case "winners":
				return ec.fieldContext_Contest_winners(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Contest", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_contest_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_currentContest(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_currentContest(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().CurrentContest(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Contest)
	fc.Result = res
	return ec.marshalOContest2githubcomKAChallengeCouncilBemagraphmodelContest(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_currentContest(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Contest_id(ctx, field)
			case "name":
				return ec.fieldContext_Contest_name(ctx, field)
			case "url":
				return ec.fieldContext_Contest_url(ctx, field)
			case "author":
				return ec.fieldContext_Contest_author(ctx, field)
			case "badgeSlug":
				return ec.fieldContext_Contest_badgeSlug(ctx, field)
			case "badgeImageUrl":
				return ec.fieldContext_Contest_badgeImageUrl(ctx, field)
			case "isCurrent":
				return ec.fieldContext_Contest_isCurrent(ctx, field)
			case "startDate":
				return ec.fieldContext_Contest_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_Contest_endDate(ctx, field)
			case "isVotingEnabled":
				return ec.fieldContext_Contest_isVotingEnabled(ctx, field)
			case "winners":
				return ec.fieldContext_Contest_winners(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Contest", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_entries(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_entries(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Entries(rctx, fc.Args["contestId"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Entry)
	fc.Result = res
	return ec.marshalNEntry2githubcomKAChallengeCouncilBemagraphmodelEntry(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_entries(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Entry_id(ctx, field)
			case "contest":
				return ec.fieldContext_Entry_contest(ctx, field)
			case "url":
				return ec.fieldContext_Entry_url(ctx, field)
			case "kaid":
				return ec.fieldContext_Entry_kaid(ctx, field)
			case "title":
				return ec.fieldContext_Entry_title(ctx, field)
			case "author":
				return ec.fieldContext_Entry_author(ctx, field)
			case "skillLevel":
				return ec.fieldContext_Entry_skillLevel(ctx, field)
			case "votes":
				return ec.fieldContext_Entry_votes(ctx, field)
			case "created":
				return ec.fieldContext_Entry_created(ctx, field)
			case "height":
				return ec.fieldContext_Entry_height(ctx, field)
			case "isWinner":
				return ec.fieldContext_Entry_isWinner(ctx, field)
			case "group":
				return ec.fieldContext_Entry_group(ctx, field)
			case "isFlagged":
				return ec.fieldContext_Entry_isFlagged(ctx, field)
			case "isDisqualified":
				return ec.fieldContext_Entry_isDisqualified(ctx, field)
			case "isSkillLevelLocked":
				return ec.fieldContext_Entry_isSkillLevelLocked(ctx, field)
			case "averageScore":
				return ec.fieldContext_Entry_averageScore(ctx, field)
			case "evaluationCount":
				return ec.fieldContext_Entry_evaluationCount(ctx, field)
			case "voteCount":
				return ec.fieldContext_Entry_voteCount(ctx, field)
			case "isVotedByUser":
				return ec.fieldContext_Entry_isVotedByUser(ctx, field)
			case "judgeVotes":
				return ec.fieldContext_Entry_judgeVotes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Entry", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_entries_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_entry(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_entry(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Entry(rctx, fc.Args["id"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Entry)
	fc.Result = res
	return ec.marshalOEntry2githubcomKAChallengeCouncilBemagraphmodelEntry(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_entry(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Entry_id(ctx, field)
			case "contest":
				return ec.fieldContext_Entry_contest(ctx, field)
			case "url":
				return ec.fieldContext_Entry_url(ctx, field)
			case "kaid":
				return ec.fieldContext_Entry_kaid(ctx, field)
			case "title":
				return ec.fieldContext_Entry_title(ctx, field)
			case "author":
				return ec.fieldContext_Entry_author(ctx, field)
			case "skillLevel":
				return ec.fieldContext_Entry_skillLevel(ctx, field)
			case "votes":
				return ec.fieldContext_Entry_votes(ctx, field)
			case "created":
				return ec.fieldContext_Entry_created(ctx, field)
			case "height":
				return ec.fieldContext_Entry_height(ctx, field)
			case "isWinner":
				return ec.fieldContext_Entry_isWinner(ctx, field)
			case "group":
				return ec.fieldContext_Entry_group(ctx, field)
			case "isFlagged":
				return ec.fieldContext_Entry_isFlagged(ctx, field)
			case "isDisqualified":
				return ec.fieldContext_Entry_isDisqualified(ctx, field)
			case "isSkillLevelLocked":
				return ec.fieldContext_Entry_isSkillLevelLocked(ctx, field)
			case "averageScore":
				return ec.fieldContext_Entry_averageScore(ctx, field)
			case "evaluationCount":
				return ec.fieldContext_Entry_evaluationCount(ctx, field)
			case "voteCount":
				return ec.fieldContext_Entry_voteCount(ctx, field)
			case "isVotedByUser":
				return ec.fieldContext_Entry_isVotedByUser(ctx, field)
			case "judgeVotes":
				return ec.fieldContext_Entry_judgeVotes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Entry", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_entry_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_flaggedEntries(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_flaggedEntries(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().FlaggedEntries(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			permission, err := ec.unmarshalNPermission2githubcomKAChallengeCouncilBemagraphmodelPermission(ctx, "VIEW_JUDGING_SETTINGS")
			if err != nil {
				return nil, err
			}
			nullType, err := ec.unmarshalNNullType2githubcomKAChallengeCouncilBemagraphmodelNullType(ctx, "EMPTY_ENTRY_ARRAY")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasPermission == nil {
				return nil, errors.New("directive hasPermission is not implemented")
			}
			return ec.directives.HasPermission(ctx, nil, directive0, permission, nullType, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.Entry); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/KA-Challenge-Council/Bema/graph/model.Entry`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Entry)
	fc.Result = res
	return ec.marshalNEntry2githubcomKAChallengeCouncilBemagraphmodelEntry(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_flaggedEntries(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Entry_id(ctx, field)
			case "contest":
				return ec.fieldContext_Entry_contest(ctx, field)
			case "url":
				return ec.fieldContext_Entry_url(ctx, field)
			case "kaid":
				return ec.fieldContext_Entry_kaid(ctx, field)
			case "title":
				return ec.fieldContext_Entry_title(ctx, field)
			case "author":
				return ec.fieldContext_Entry_author(ctx, field)
			case "skillLevel":
				return ec.fieldContext_Entry_skillLevel(ctx, field)
			case "votes":
				return ec.fieldContext_Entry_votes(ctx, field)
			case "created":
				return ec.fieldContext_Entry_created(ctx, field)
			case "height":
				return ec.fieldContext_Entry_height(ctx, field)
			case "isWinner":
				return ec.fieldContext_Entry_isWinner(ctx, field)
			case "group":
				return ec.fieldContext_Entry_group(ctx, field)
			case "isFlagged":
				return ec.fieldContext_Entry_isFlagged(ctx, field)
			case "isDisqualified":
				return ec.fieldContext_Entry_isDisqualified(ctx, field)
			case "isSkillLevelLocked":
				return ec.fieldContext_Entry_isSkillLevelLocked(ctx, field)
			case "averageScore":
				return ec.fieldContext_Entry_averageScore(ctx, field)
			case "evaluationCount":
				return ec.fieldContext_Entry_evaluationCount(ctx, field)
			case "voteCount":
				return ec.fieldContext_Entry_voteCount(ctx, field)
			case "isVotedByUser":
				return ec.fieldContext_Entry_isVotedByUser(ctx, field)
			case "judgeVotes":
				return ec.fieldContext_Entry_judgeVotes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Entry", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_entriesByAverageScore(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_entriesByAverageScore(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().EntriesByAverageScore(rctx, fc.Args["contestId"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Entry)
	fc.Result = res
	return ec.marshalNEntry2githubcomKAChallengeCouncilBemagraphmodelEntry(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_entriesByAverageScore(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Entry_id(ctx, field)
			case "contest":
				return ec.fieldContext_Entry_contest(ctx, field)
			case "url":
				return ec.fieldContext_Entry_url(ctx, field)
			case "kaid":
				return ec.fieldContext_Entry_kaid(ctx, field)
			case "title":
				return ec.fieldContext_Entry_title(ctx, field)
			case "author":
				return ec.fieldContext_Entry_author(ctx, field)
			case "skillLevel":
				return ec.fieldContext_Entry_skillLevel(ctx, field)
			case "votes":
				return ec.fieldContext_Entry_votes(ctx, field)
			case "created":
				return ec.fieldContext_Entry_created(ctx, field)
			case "height":
				return ec.fieldContext_Entry_height(ctx, field)
			case "isWinner":
				return ec.fieldContext_Entry_isWinner(ctx, field)
			case "group":
				return ec.fieldContext_Entry_group(ctx, field)
			case "isFlagged":
				return ec.fieldContext_Entry_isFlagged(ctx, field)
			case "isDisqualified":
				return ec.fieldContext_Entry_isDisqualified(ctx, field)
			case "isSkillLevelLocked":
				return ec.fieldContext_Entry_isSkillLevelLocked(ctx, field)
			case "averageScore":
				return ec.fieldContext_Entry_averageScore(ctx, field)
			case "evaluationCount":
				return ec.fieldContext_Entry_evaluationCount(ctx, field)
			case "voteCount":
				return ec.fieldContext_Entry_voteCount(ctx, field)
			case "isVotedByUser":
				return ec.fieldContext_Entry_isVotedByUser(ctx, field)
			case "judgeVotes":
				return ec.fieldContext_Entry_judgeVotes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Entry", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_entriesByAverageScore_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_entriesPerLevel(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_entriesPerLevel(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().EntriesPerLevel(rctx, fc.Args["contestId"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.EntriesPerLevel)
	fc.Result = res
	return ec.marshalNEntriesPerLevel2githubcomKAChallengeCouncilBemagraphmodelEntriesPerLevel(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_entriesPerLevel(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "level":
				return ec.fieldContext_EntriesPerLevel_level(ctx, field)
			case "count":
				return ec.fieldContext_EntriesPerLevel_count(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EntriesPerLevel", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_entriesPerLevel_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_errors(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Errors(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			permission, err := ec.unmarshalNPermission2githubcomKAChallengeCouncilBemagraphmodelPermission(ctx, "VIEW_ERRORS")
			if err != nil {
				return nil, err
			}
			nullType, err := ec.unmarshalNNullType2githubcomKAChallengeCouncilBemagraphmodelNullType(ctx, "NULL")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasPermission == nil {
				return nil, errors.New("directive hasPermission is not implemented")
			}
			return ec.directives.HasPermission(ctx, nil, directive0, permission, nullType, nil)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			permission, err := ec.unmarshalNPermission2githubcomKAChallengeCouncilBemagraphmodelPermission(ctx, "VIEW_ERRORS")
			if err != nil {
				return nil, err
			}
			nullType, err := ec.unmarshalNNullType2githubcomKAChallengeCouncilBemagraphmodelNullType(ctx, "EMPTY_ERRORS_ARRAY")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasPermission == nil {
				return nil, errors.New("directive hasPermission is not implemented")
			}
			return ec.directives.HasPermission(ctx, nil, directive1, permission, nullType, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.Error); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/KA-Challenge-Council/Bema/graph/model.Error`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Error)
	fc.Result = res
	return ec.marshalNError2githubcomKAChallengeCouncilBemagraphmodelError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Error_id(ctx, field)
			case "message":
				return ec.fieldContext_Error_message(ctx, field)
			case "stack":
				return ec.fieldContext_Error_stack(ctx, field)
			case "timestamp":
				return ec.fieldContext_Error_timestamp(ctx, field)
			case "requestOrigin":
				return ec.fieldContext_Error_requestOrigin(ctx, field)
			case "requestReferrer":
				return ec.fieldContext_Error_requestReferrer(ctx, field)
			case "requestUserAgent":
				return ec.fieldContext_Error_requestUserAgent(ctx, field)
			case "user":
				return ec.fieldContext_Error_user(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Error", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_error(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Error(rctx, fc.Args["id"].(int))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			permission, err := ec.unmarshalNPermission2githubcomKAChallengeCouncilBemagraphmodelPermission(ctx, "VIEW_ERRORS")
			if err != nil {
				return nil, err
			}
			nullType, err := ec.unmarshalNNullType2githubcomKAChallengeCouncilBemagraphmodelNullType(ctx, "NULL")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasPermission == nil {
				return nil, errors.New("directive hasPermission is not implemented")
			}
			return ec.directives.HasPermission(ctx, nil, directive0, permission, nullType, nil)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			permission, err := ec.unmarshalNPermission2githubcomKAChallengeCouncilBemagraphmodelPermission(ctx, "VIEW_ERRORS")
			if err != nil {
				return nil, err
			}
			nullType, err := ec.unmarshalNNullType2githubcomKAChallengeCouncilBemagraphmodelNullType(ctx, "NULL")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasPermission == nil {
				return nil, errors.New("directive hasPermission is not implemented")
			}
			return ec.directives.HasPermission(ctx, nil, directive1, permission, nullType, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.Error); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/KA-Challenge-Council/Bema/graph/model.Error`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Error)
	fc.Result = res
	return ec.marshalOError2githubcomKAChallengeCouncilBemagraphmodelError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_error(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Error_id(ctx, field)
			case "message":
				return ec.fieldContext_Error_message(ctx, field)
			case "stack":
				return ec.fieldContext_Error_stack(ctx, field)
			case "timestamp":
				return ec.fieldContext_Error_timestamp(ctx, field)
			case "requestOrigin":
				return ec.fieldContext_Error_requestOrigin(ctx, field)
			case "requestReferrer":
				return ec.fieldContext_Error_requestReferrer(ctx, field)
			case "requestUserAgent":
				return ec.fieldContext_Error_requestUserAgent(ctx, field)
			case "user":
				return ec.fieldContext_Error_user(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Error", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_error_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_allCriteria(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_allCriteria(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().AllCriteria(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			permission, err := ec.unmarshalNPermission2githubcomKAChallengeCouncilBemagraphmodelPermission(ctx, "VIEW_JUDGING_SETTINGS")
			if err != nil {
				return nil, err
			}
			nullType, err := ec.unmarshalNNullType2githubcomKAChallengeCouncilBemagraphmodelNullType(ctx, "EMPTY_JUDGING_CRITERIA_ARRAY")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasPermission == nil {
				return nil, errors.New("directive hasPermission is not implemented")
			}
			return ec.directives.HasPermission(ctx, nil, directive0, permission, nullType, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.JudgingCriteria); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/KA-Challenge-Council/Bema/graph/model.JudgingCriteria`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.JudgingCriteria)
	fc.Result = res
	return ec.marshalNJudgingCriteria2githubcomKAChallengeCouncilBemagraphmodelJudgingCriteria(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_allCriteria(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_JudgingCriteria_id(ctx, field)
			case "name":
				return ec.fieldContext_JudgingCriteria_name(ctx, field)
			case "description":
				return ec.fieldContext_JudgingCriteria_description(ctx, field)
			case "isActive":
				return ec.fieldContext_JudgingCriteria_isActive(ctx, field)
			case "sortOrder":
				return ec.fieldContext_JudgingCriteria_sortOrder(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type JudgingCriteria", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_activeCriteria(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_activeCriteria(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ActiveCriteria(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.JudgingCriteria)
	fc.Result = res
	return ec.marshalNJudgingCriteria2githubcomKAChallengeCouncilBemagraphmodelJudgingCriteria(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_activeCriteria(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_JudgingCriteria_id(ctx, field)
			case "name":
				return ec.fieldContext_JudgingCriteria_name(ctx, field)
			case "description":
				return ec.fieldContext_JudgingCriteria_description(ctx, field)
			case "isActive":
				return ec.fieldContext_JudgingCriteria_isActive(ctx, field)
			case "sortOrder":
				return ec.fieldContext_JudgingCriteria_sortOrder(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type JudgingCriteria", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_allJudgingGroups(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_allJudgingGroups(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().AllJudgingGroups(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			nullType, err := ec.unmarshalNNullType2githubcomKAChallengeCouncilBemagraphmodelNullType(ctx, "NULL")
			if err != nil {
				return nil, err
			}
			if ec.directives.IsAuthenticated == nil {
				return nil, errors.New("directive isAuthenticated is not implemented")
			}
			return ec.directives.IsAuthenticated(ctx, nil, directive0, nullType)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			permission, err := ec.unmarshalNPermission2githubcomKAChallengeCouncilBemagraphmodelPermission(ctx, "VIEW_JUDGING_SETTINGS")
			if err != nil {
				return nil, err
			}
			nullType, err := ec.unmarshalNNullType2githubcomKAChallengeCouncilBemagraphmodelNullType(ctx, "EMPTY_JUDGING_GROUP_ARRAY")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasPermission == nil {
				return nil, errors.New("directive hasPermission is not implemented")
			}
			return ec.directives.HasPermission(ctx, nil, directive1, permission, nullType, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.JudgingGroup); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/KA-Challenge-Council/Bema/graph/model.JudgingGroup`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.JudgingGroup)
	fc.Result = res
	return ec.marshalNJudgingGroup2githubcomKAChallengeCouncilBemagraphmodelJudgingGroup(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_allJudgingGroups(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_JudgingGroup_id(ctx, field)
			case "name":
				return ec.fieldContext_JudgingGroup_name(ctx, field)
			case "isActive":
				return ec.fieldContext_JudgingGroup_isActive(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type JudgingGroup", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_activeJudgingGroups(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_activeJudgingGroups(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ActiveJudgingGroups(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			nullType, err := ec.unmarshalNNullType2githubcomKAChallengeCouncilBemagraphmodelNullType(ctx, "NULL")
			if err != nil {
				return nil, err
			}
			if ec.directives.IsAuthenticated == nil {
				return nil, errors.New("directive isAuthenticated is not implemented")
			}
			return ec.directives.IsAuthenticated(ctx, nil, directive0, nullType)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			nullType, err := ec.unmarshalNNullType2githubcomKAChallengeCouncilBemagraphmodelNullType(ctx, "EMPTY_JUDGING_GROUP_ARRAY")
			if err != nil {
				return nil, err
			}
			if ec.directives.IsAuthenticated == nil {
				return nil, errors.New("directive isAuthenticated is not implemented")
			}
			return ec.directives.IsAuthenticated(ctx, nil, directive1, nullType)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.JudgingGroup); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/KA-Challenge-Council/Bema/graph/model.JudgingGroup`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.JudgingGroup)
	fc.Result = res
	return ec.marshalNJudgingGroup2githubcomKAChallengeCouncilBemagraphmodelJudgingGroup(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_activeJudgingGroups(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_JudgingGroup_id(ctx, field)
			case "name":
				return ec.fieldContext_JudgingGroup_name(ctx, field)
			case "isActive":
				return ec.fieldContext_JudgingGroup_isActive(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type JudgingGroup", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_judgingGroup(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_judgingGroup(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().JudgingGroup(rctx, fc.Args["id"].(int))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			nullType, err := ec.unmarshalNNullType2githubcomKAChallengeCouncilBemagraphmodelNullType(ctx, "NULL")
			if err != nil {
				return nil, err
			}
			if ec.directives.IsAuthenticated == nil {
				return nil, errors.New("directive isAuthenticated is not implemented")
			}
			return ec.directives.IsAuthenticated(ctx, nil, directive0, nullType)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			nullType, err := ec.unmarshalNNullType2githubcomKAChallengeCouncilBemagraphmodelNullType(ctx, "NULL")
			if err != nil {
				return nil, err
			}
			if ec.directives.IsAuthenticated == nil {
				return nil, errors.New("directive isAuthenticated is not implemented")
			}
			return ec.directives.IsAuthenticated(ctx, nil, directive1, nullType)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.JudgingGroup); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/KA-Challenge-Council/Bema/graph/model.JudgingGroup`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.JudgingGroup)
	fc.Result = res
	return ec.marshalOJudgingGroup2githubcomKAChallengeCouncilBemagraphmodelJudgingGroup(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_judgingGroup(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_JudgingGroup_id(ctx, field)
			case "name":
				return ec.fieldContext_JudgingGroup_name(ctx, field)
			case "isActive":
				return ec.fieldContext_JudgingGroup_isActive(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type JudgingGroup", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_judgingGroup_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_tasks(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_tasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Tasks(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			permission, err := ec.unmarshalNPermission2githubcomKAChallengeCouncilBemagraphmodelPermission(ctx, "VIEW_ALL_TASKS")
			if err != nil {
				return nil, err
			}
			nullType, err := ec.unmarshalNNullType2githubcomKAChallengeCouncilBemagraphmodelNullType(ctx, "NULL")
			if err != nil {
				return nil, err
			}
			objType, err := ec.unmarshalOObjectType2githubcomKAChallengeCouncilBemagraphmodelObjectType(ctx, "TASK")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasPermission == nil {
				return nil, errors.New("directive hasPermission is not implemented")
			}
			return ec.directives.HasPermission(ctx, nil, directive0, permission, nullType, objType)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			permission, err := ec.unmarshalNPermission2githubcomKAChallengeCouncilBemagraphmodelPermission(ctx, "VIEW_ALL_TASKS")
			if err != nil {
				return nil, err
			}
			nullType, err := ec.unmarshalNNullType2githubcomKAChallengeCouncilBemagraphmodelNullType(ctx, "EMPTY_TASK_ARRAY")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasPermission == nil {
				return nil, errors.New("directive hasPermission is not implemented")
			}
			return ec.directives.HasPermission(ctx, nil, directive1, permission, nullType, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.Task); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/KA-Challenge-Council/Bema/graph/model.Task`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Task)
	fc.Result = res
	return ec.marshalNTask2githubcomKAChallengeCouncilBemagraphmodelTask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_tasks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "title":
				return ec.fieldContext_Task_title(ctx, field)
			case "assignedUser":
				return ec.fieldContext_Task_assignedUser(ctx, field)
			case "status":
				return ec.fieldContext_Task_status(ctx, field)
			case "dueDate":
				return ec.fieldContext_Task_dueDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_completedTasks(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_completedTasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().CompletedTasks(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			permission, err := ec.unmarshalNPermission2githubcomKAChallengeCouncilBemagraphmodelPermission(ctx, "VIEW_ALL_TASKS")
			if err != nil {
				return nil, err
			}
			nullType, err := ec.unmarshalNNullType2githubcomKAChallengeCouncilBemagraphmodelNullType(ctx, "NULL")
			if err != nil {
				return nil, err
			}
			objType, err := ec.unmarshalOObjectType2githubcomKAChallengeCouncilBemagraphmodelObjectType(ctx, "TASK")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasPermission == nil {
				return nil, errors.New("directive hasPermission is not implemented")
			}
			return ec.directives.HasPermission(ctx, nil, directive0, permission, nullType, objType)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			permission, err := ec.unmarshalNPermission2githubcomKAChallengeCouncilBemagraphmodelPermission(ctx, "VIEW_ALL_TASKS")
			if err != nil {
				return nil, err
			}
			nullType, err := ec.unmarshalNNullType2githubcomKAChallengeCouncilBemagraphmodelNullType(ctx, "EMPTY_TASK_ARRAY")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasPermission == nil {
				return nil, errors.New("directive hasPermission is not implemented")
			}
			return ec.directives.HasPermission(ctx, nil, directive1, permission, nullType, nil)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.Task); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/KA-Challenge-Council/Bema/graph/model.Task`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Task)
	fc.Result = res
	return ec.marshalNTask2githubcomKAChallengeCouncilBemagraphmodelTask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_completedTasks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "title":
				return ec.fieldContext_Task_title(ctx, field)
			case "assignedUser":
				return ec.fieldContext_Task_assignedUser(ctx, field)
			case "status":
				return ec.fieldContext_Task_status(ctx, field)
			case "dueDate":
				return ec.fieldContext_Task_dueDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_availableTasks(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_availableTasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().AvailableTasks(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			permission, err := ec.unmarshalNPermission2githubcomKAChallengeCouncilBemagraphmodelPermission(ctx, "VIEW_ALL_TASKS")
			if err != nil {
				return nil, err
			}
			nullType, err := ec.unmarshalNNullType2githubcomKAChallengeCouncilBemagraphmodelNullType(ctx, "NULL")
			if err != nil {
				return nil, err
			}
			objType, err := ec.unmarshalOObjectType2githubcomKAChallengeCouncilBemagraphmodelObjectType(ctx, "TASK")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasPermission == nil {
				return nil, errors.New("directive hasPermission is not implemented")
			}
			return ec.directives.HasPermission(ctx, nil, directive0, permission, nullType, objType)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			nullType, err := ec.unmarshalNNullType2githubcomKAChallengeCouncilBemagraphmodelNullType(ctx, "EMPTY_TASK_ARRAY")
			if err != nil {
				return nil, err
			}
			if ec.directives.IsAuthenticated == nil {
				return nil, errors.New("directive isAuthenticated is not implemented")
			}
			return ec.directives.IsAuthenticated(ctx, nil, directive1, nullType)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.Task); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/KA-Challenge-Council/Bema/graph/model.Task`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Task)
	fc.Result = res
	return ec.marshalNTask2githubcomKAChallengeCouncilBemagraphmodelTask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_availableTasks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "title":
				return ec.fieldContext_Task_title(ctx, field)
			case "assignedUser":
				return ec.fieldContext_Task_assignedUser(ctx, field)
			case "status":
				return ec.fieldContext_Task_status(ctx, field)
			case "dueDate":
				return ec.fieldContext_Task_dueDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_currentUserTasks(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_currentUserTasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().CurrentUserTasks(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			permission, err := ec.unmarshalNPermission2githubcomKAChallengeCouncilBemagraphmodelPermission(ctx, "VIEW_ALL_TASKS")
			if err != nil {
				return nil, err
			}
			nullType, err := ec.unmarshalNNullType2githubcomKAChallengeCouncilBemagraphmodelNullType(ctx, "NULL")
			if err != nil {
				return nil, err
			}
			objType, err := ec.unmarshalOObjectType2githubcomKAChallengeCouncilBemagraphmodelObjectType(ctx, "TASK")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasPermission == nil {
				return nil, errors.New("directive hasPermission is not implemented")
			}
			return ec.directives.HasPermission(ctx, nil, directive0, permission, nullType, objType)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			nullType, err := ec.unmarshalNNullType2githubcomKAChallengeCouncilBemagraphmodelNullType(ctx, "EMPTY_TASK_ARRAY")
			if err != nil {
				return nil, err
			}
			if ec.directives.IsAuthenticated == nil {
				return nil, errors.New("directive isAuthenticated is not implemented")
			}
			return ec.directives.IsAuthenticated(ctx, nil, directive1, nullType)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.Task); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/KA-Challenge-Council/Bema/graph/model.Task`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Task)
	fc.Result = res
	return ec.marshalNTask2githubcomKAChallengeCouncilBemagraphmodelTask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_currentUserTasks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "title":
				return ec.fieldContext_Task_title(ctx, field)
			case "assignedUser":
				return ec.fieldContext_Task_assignedUser(ctx, field)
			case "status":
				return ec.fieldContext_Task_status(ctx, field)
			case "dueDate":
				return ec.fieldContext_Task_dueDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_currentUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_currentUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().CurrentUser(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.FullUserProfile)
	fc.Result = res
	return ec.marshalNFullUserProfile2githubcomKAChallengeCouncilBemagraphmodelFullUserProfile(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_currentUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "isAdmin":
				return ec.fieldContext_FullUserProfile_isAdmin(ctx, field)
			case "isImpersonated":
				return ec.fieldContext_FullUserProfile_isImpersonated(ctx, field)
			case "loggedIn":
				return ec.fieldContext_FullUserProfile_loggedIn(ctx, field)
			case "originKaid":
				return ec.fieldContext_FullUserProfile_originKaid(ctx, field)
			case "user":
				return ec.fieldContext_FullUserProfile_user(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FullUserProfile", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_users(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_users(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Users(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			nullType, err := ec.unmarshalNNullType2githubcomKAChallengeCouncilBemagraphmodelNullType(ctx, "NULL")
			if err != nil {
				return nil, err
			}
			if ec.directives.IsAuthenticated == nil {
				return nil, errors.New("directive isAuthenticated is not implemented")
			}
			return ec.directives.IsAuthenticated(ctx, nil, directive0, nullType)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			nullType, err := ec.unmarshalNNullType2githubcomKAChallengeCouncilBemagraphmodelNullType(ctx, "EMPTY_USER_ARRAY")
			if err != nil {
				return nil, err
			}
			if ec.directives.IsAuthenticated == nil {
				return nil, errors.New("directive isAuthenticated is not implemented")
			}
			return ec.directives.IsAuthenticated(ctx, nil, directive1, nullType)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.User); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/KA-Challenge-Council/Bema/graph/model.User`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.User)
	fc.Result = res
	return ec.marshalNUser2githubcomKAChallengeCouncilBemagraphmodelUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_users(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "kaid":
				return ec.fieldContext_User_kaid(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "nickname":
				return ec.fieldContext_User_nickname(ctx, field)
			case "username":
				return ec.fieldContext_User_username(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "accountLocked":
				return ec.fieldContext_User_accountLocked(ctx, field)
			case "permissions":
				return ec.fieldContext_User_permissions(ctx, field)
			case "isAdmin":
				return ec.fieldContext_User_isAdmin(ctx, field)
			case "lastLogin":
				return ec.fieldContext_User_lastLogin(ctx, field)
			case "termStart":
				return ec.fieldContext_User_termStart(ctx, field)
			case "termEnd":
				return ec.fieldContext_User_termEnd(ctx, field)
			case "notificationsEnabled":
				return ec.fieldContext_User_notificationsEnabled(ctx, field)
			case "assignedGroup":
				return ec.fieldContext_User_assignedGroup(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_inactiveUsers(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_inactiveUsers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().InactiveUsers(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			nullType, err := ec.unmarshalNNullType2githubcomKAChallengeCouncilBemagraphmodelNullType(ctx, "NULL")
			if err != nil {
				return nil, err
			}
			if ec.directives.IsAuthenticated == nil {
				return nil, errors.New("directive isAuthenticated is not implemented")
			}
			return ec.directives.IsAuthenticated(ctx, nil, directive0, nullType)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			nullType, err := ec.unmarshalNNullType2githubcomKAChallengeCouncilBemagraphmodelNullType(ctx, "EMPTY_USER_ARRAY")
			if err != nil {
				return nil, err
			}
			if ec.directives.IsAuthenticated == nil {
				return nil, errors.New("directive isAuthenticated is not implemented")
			}
			return ec.directives.IsAuthenticated(ctx, nil, directive1, nullType)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.User); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/KA-Challenge-Council/Bema/graph/model.User`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.User)
	fc.Result = res
	return ec.marshalNUser2githubcomKAChallengeCouncilBemagraphmodelUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_inactiveUsers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "kaid":
				return ec.fieldContext_User_kaid(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "nickname":
				return ec.fieldContext_User_nickname(ctx, field)
			case "username":
				return ec.fieldContext_User_username(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "accountLocked":
				return ec.fieldContext_User_accountLocked(ctx, field)
			case "permissions":
				return ec.fieldContext_User_permissions(ctx, field)
			case "isAdmin":
				return ec.fieldContext_User_isAdmin(ctx, field)
			case "lastLogin":
				return ec.fieldContext_User_lastLogin(ctx, field)
			case "termStart":
				return ec.fieldContext_User_termStart(ctx, field)
			case "termEnd":
				return ec.fieldContext_User_termEnd(ctx, field)
			case "notificationsEnabled":
				return ec.fieldContext_User_notificationsEnabled(ctx, field)
			case "assignedGroup":
				return ec.fieldContext_User_assignedGroup(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_user(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().User(rctx, fc.Args["id"].(int))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			nullType, err := ec.unmarshalNNullType2githubcomKAChallengeCouncilBemagraphmodelNullType(ctx, "NULL")
			if err != nil {
				return nil, err
			}
			if ec.directives.IsAuthenticated == nil {
				return nil, errors.New("directive isAuthenticated is not implemented")
			}
			return ec.directives.IsAuthenticated(ctx, nil, directive0, nullType)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.User); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/KA-Challenge-Council/Bema/graph/model.User`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.User)
	fc.Result = res
	return ec.marshalOUser2githubcomKAChallengeCouncilBemagraphmodelUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_user(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "kaid":
				return ec.fieldContext_User_kaid(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "nickname":
				return ec.fieldContext_User_nickname(ctx, field)
			case "username":
				return ec.fieldContext_User_username(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "accountLocked":
				return ec.fieldContext_User_accountLocked(ctx, field)
			case "permissions":
				return ec.fieldContext_User_permissions(ctx, field)
			case "isAdmin":
				return ec.fieldContext_User_isAdmin(ctx, field)
			case "lastLogin":
				return ec.fieldContext_User_lastLogin(ctx, field)
			case "termStart":
				return ec.fieldContext_User_termStart(ctx, field)
			case "termEnd":
				return ec.fieldContext_User_termEnd(ctx, field)
			case "notificationsEnabled":
				return ec.fieldContext_User_notificationsEnabled(ctx, field)
			case "assignedGroup":
				return ec.fieldContext_User_assignedGroup(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_user_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query___type_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___schema(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___schema(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext___Schema_description(ctx, field)
			case "types":
				return ec.fieldContext___Schema_types(ctx, field)
			case "queryType":
				return ec.fieldContext___Schema_queryType(ctx, field)
			case "mutationType":
				return ec.fieldContext___Schema_mutationType(ctx, field)
			case "subscriptionType":
				return ec.fieldContext___Schema_subscriptionType(ctx, field)
			case "directives":
				return ec.fieldContext___Schema_directives(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Schema", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_id(ctx context.Context, field graphql.CollectedField, obj *model.Task) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_title(ctx context.Context, field graphql.CollectedField, obj *model.Task) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_title(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Title, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_title(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_assignedUser(ctx context.Context, field graphql.CollectedField, obj *model.Task) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_assignedUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Task().AssignedUser(rctx, obj)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			nullType, err := ec.unmarshalNNullType2githubcomKAChallengeCouncilBemagraphmodelNullType(ctx, "NULL")
			if err != nil {
				return nil, err
			}
			if ec.directives.IsAuthenticated == nil {
				return nil, errors.New("directive isAuthenticated is not implemented")
			}
			return ec.directives.IsAuthenticated(ctx, obj, directive0, nullType)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.User); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/KA-Challenge-Council/Bema/graph/model.User`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.User)
	fc.Result = res
	return ec.marshalOUser2githubcomKAChallengeCouncilBemagraphmodelUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_assignedUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "kaid":
				return ec.fieldContext_User_kaid(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "nickname":
				return ec.fieldContext_User_nickname(ctx, field)
			case "username":
				return ec.fieldContext_User_username(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "accountLocked":
				return ec.fieldContext_User_accountLocked(ctx, field)
			case "permissions":
				return ec.fieldContext_User_permissions(ctx, field)
			case "isAdmin":
				return ec.fieldContext_User_isAdmin(ctx, field)
			case "lastLogin":
				return ec.fieldContext_User_lastLogin(ctx, field)
			case "termStart":
				return ec.fieldContext_User_termStart(ctx, field)
			case "termEnd":
				return ec.fieldContext_User_termEnd(ctx, field)
			case "notificationsEnabled":
				return ec.fieldContext_User_notificationsEnabled(ctx, field)
			case "assignedGroup":
				return ec.fieldContext_User_assignedGroup(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_status(ctx context.Context, field graphql.CollectedField, obj *model.Task) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_dueDate(ctx context.Context, field graphql.CollectedField, obj *model.Task) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_dueDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DueDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_dueDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_id(ctx context.Context, field graphql.CollectedField, obj *model.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_kaid(ctx context.Context, field graphql.CollectedField, obj *model.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_kaid(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kaid, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_kaid(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_name(ctx context.Context, field graphql.CollectedField, obj *model.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.User().Name(rctx, obj)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			permission, err := ec.unmarshalNPermission2githubcomKAChallengeCouncilBemagraphmodelPermission(ctx, "VIEW_ALL_USERS")
			if err != nil {
				return nil, err
			}
			nullType, err := ec.unmarshalNNullType2githubcomKAChallengeCouncilBemagraphmodelNullType(ctx, "NULL")
			if err != nil {
				return nil, err
			}
			objType, err := ec.unmarshalOObjectType2githubcomKAChallengeCouncilBemagraphmodelObjectType(ctx, "USER")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasPermission == nil {
				return nil, errors.New("directive hasPermission is not implemented")
			}
			return ec.directives.HasPermission(ctx, obj, directive0, permission, nullType, objType)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_nickname(ctx context.Context, field graphql.CollectedField, obj *model.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_nickname(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nickname, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_nickname(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_username(ctx context.Context, field graphql.CollectedField, obj *model.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_username(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Username, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_username(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_email(ctx context.Context, field graphql.CollectedField, obj *model.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_email(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.User().Email(rctx, obj)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			permission, err := ec.unmarshalNPermission2githubcomKAChallengeCouncilBemagraphmodelPermission(ctx, "VIEW_ALL_USERS")
			if err != nil {
				return nil, err
			}
			nullType, err := ec.unmarshalNNullType2githubcomKAChallengeCouncilBemagraphmodelNullType(ctx, "NULL")
			if err != nil {
				return nil, err
			}
			objType, err := ec.unmarshalOObjectType2githubcomKAChallengeCouncilBemagraphmodelObjectType(ctx, "USER")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasPermission == nil {
				return nil, errors.New("directive hasPermission is not implemented")
			}
			return ec.directives.HasPermission(ctx, obj, directive0, permission, nullType, objType)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_email(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_accountLocked(ctx context.Context, field graphql.CollectedField, obj *model.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_accountLocked(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.User().AccountLocked(rctx, obj)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			permission, err := ec.unmarshalNPermission2githubcomKAChallengeCouncilBemagraphmodelPermission(ctx, "VIEW_ALL_USERS")
			if err != nil {
				return nil, err
			}
			nullType, err := ec.unmarshalNNullType2githubcomKAChallengeCouncilBemagraphmodelNullType(ctx, "NULL")
			if err != nil {
				return nil, err
			}
			objType, err := ec.unmarshalOObjectType2githubcomKAChallengeCouncilBemagraphmodelObjectType(ctx, "USER")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasPermission == nil {
				return nil, errors.New("directive hasPermission is not implemented")
			}
			return ec.directives.HasPermission(ctx, obj, directive0, permission, nullType, objType)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_accountLocked(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_permissions(ctx context.Context, field graphql.CollectedField, obj *model.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_permissions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.User().Permissions(rctx, obj)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			permission, err := ec.unmarshalNPermission2githubcomKAChallengeCouncilBemagraphmodelPermission(ctx, "VIEW_ALL_USERS")
			if err != nil {
				return nil, err
			}
			nullType, err := ec.unmarshalNNullType2githubcomKAChallengeCouncilBemagraphmodelNullType(ctx, "NULL")
			if err != nil {
				return nil, err
			}
			objType, err := ec.unmarshalOObjectType2githubcomKAChallengeCouncilBemagraphmodelObjectType(ctx, "USER")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasPermission == nil {
				return nil, errors.New("directive hasPermission is not implemented")
			}
			return ec.directives.HasPermission(ctx, obj, directive0, permission, nullType, objType)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.Permissions); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/KA-Challenge-Council/Bema/graph/model.Permissions`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Permissions)
	fc.Result = res
	return ec.marshalOPermissions2githubcomKAChallengeCouncilBemagraphmodelPermissions(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_permissions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "add_entries":
				return ec.fieldContext_Permissions_add_entries(ctx, field)
			case "add_users":
				return ec.fieldContext_Permissions_add_users(ctx, field)
			case "assign_entry_groups":
				return ec.fieldContext_Permissions_assign_entry_groups(ctx, field)
			case "assign_evaluator_groups":
				return ec.fieldContext_Permissions_assign_evaluator_groups(ctx, field)
			case "assume_user_identities":
				return ec.fieldContext_Permissions_assume_user_identities(ctx, field)
			case "change_user_passwords":
				return ec.fieldContext_Permissions_change_user_passwords(ctx, field)
			case "delete_all_evaluations":
				return ec.fieldContext_Permissions_delete_all_evaluations(ctx, field)
			case "delete_all_tasks":
				return ec.fieldContext_Permissions_delete_all_tasks(ctx, field)
			case "delete_contests":
				return ec.fieldContext_Permissions_delete_contests(ctx, field)
			case "delete_entries":
				return ec.fieldContext_Permissions_delete_entries(ctx, field)
			case "delete_errors":
				return ec.fieldContext_Permissions_delete_errors(ctx, field)
			case "delete_kb_content":
				return ec.fieldContext_Permissions_delete_kb_content(ctx, field)
			case "edit_all_evaluations":
				return ec.fieldContext_Permissions_edit_all_evaluations(ctx, field)
			case "edit_all_tasks":
				return ec.fieldContext_Permissions_edit_all_tasks(ctx, field)
			case "edit_contests":
				return ec.fieldContext_Permissions_edit_contests(ctx, field)
			case "edit_entries":
				return ec.fieldContext_Permissions_edit_entries(ctx, field)
			case "edit_kb_content":
				return ec.fieldContext_Permissions_edit_kb_content(ctx, field)
			case "edit_user_profiles":
				return ec.fieldContext_Permissions_edit_user_profiles(ctx, field)
			case "judge_entries":
				return ec.fieldContext_Permissions_judge_entries(ctx, field)
			case "manage_announcements":
				return ec.fieldContext_Permissions_manage_announcements(ctx, field)
			case "manage_judging_criteria":
				return ec.fieldContext_Permissions_manage_judging_criteria(ctx, field)
			case "manage_judging_groups":
				return ec.fieldContext_Permissions_manage_judging_groups(ctx, field)
			case "manage_winners":
				return ec.fieldContext_Permissions_manage_winners(ctx, field)
			case "publish_kb_content":
				return ec.fieldContext_Permissions_publish_kb_content(ctx, field)
			case "view_admin_stats":
				return ec.fieldContext_Permissions_view_admin_stats(ctx, field)
			case "view_all_evaluations":
				return ec.fieldContext_Permissions_view_all_evaluations(ctx, field)
			case "view_all_tasks":
				return ec.fieldContext_Permissions_view_all_tasks(ctx, field)
			case "view_all_users":
				return ec.fieldContext_Permissions_view_all_users(ctx, field)
			case "view_errors":
				return ec.fieldContext_Permissions_view_errors(ctx, field)
			case "view_judging_settings":
				return ec.fieldContext_Permissions_view_judging_settings(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Permissions", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_isAdmin(ctx context.Context, field graphql.CollectedField, obj *model.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_isAdmin(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.User().IsAdmin(rctx, obj)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			permission, err := ec.unmarshalNPermission2githubcomKAChallengeCouncilBemagraphmodelPermission(ctx, "VIEW_ALL_USERS")
			if err != nil {
				return nil, err
			}
			nullType, err := ec.unmarshalNNullType2githubcomKAChallengeCouncilBemagraphmodelNullType(ctx, "NULL")
			if err != nil {
				return nil, err
			}
			objType, err := ec.unmarshalOObjectType2githubcomKAChallengeCouncilBemagraphmodelObjectType(ctx, "USER")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasPermission == nil {
				return nil, errors.New("directive hasPermission is not implemented")
			}
			return ec.directives.HasPermission(ctx, obj, directive0, permission, nullType, objType)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_isAdmin(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_lastLogin(ctx context.Context, field graphql.CollectedField, obj *model.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_lastLogin(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.User().LastLogin(rctx, obj)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			permission, err := ec.unmarshalNPermission2githubcomKAChallengeCouncilBemagraphmodelPermission(ctx, "VIEW_ALL_USERS")
			if err != nil {
				return nil, err
			}
			nullType, err := ec.unmarshalNNullType2githubcomKAChallengeCouncilBemagraphmodelNullType(ctx, "NULL")
			if err != nil {
				return nil, err
			}
			objType, err := ec.unmarshalOObjectType2githubcomKAChallengeCouncilBemagraphmodelObjectType(ctx, "USER")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasPermission == nil {
				return nil, errors.New("directive hasPermission is not implemented")
			}
			return ec.directives.HasPermission(ctx, obj, directive0, permission, nullType, objType)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_lastLogin(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_termStart(ctx context.Context, field graphql.CollectedField, obj *model.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_termStart(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TermStart, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_termStart(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_termEnd(ctx context.Context, field graphql.CollectedField, obj *model.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_termEnd(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TermEnd, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_termEnd(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_notificationsEnabled(ctx context.Context, field graphql.CollectedField, obj *model.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_notificationsEnabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.User().NotificationsEnabled(rctx, obj)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			permission, err := ec.unmarshalNPermission2githubcomKAChallengeCouncilBemagraphmodelPermission(ctx, "VIEW_ALL_USERS")
			if err != nil {
				return nil, err
			}
			nullType, err := ec.unmarshalNNullType2githubcomKAChallengeCouncilBemagraphmodelNullType(ctx, "NULL")
			if err != nil {
				return nil, err
			}
			objType, err := ec.unmarshalOObjectType2githubcomKAChallengeCouncilBemagraphmodelObjectType(ctx, "USER")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasPermission == nil {
				return nil, errors.New("directive hasPermission is not implemented")
			}
			return ec.directives.HasPermission(ctx, obj, directive0, permission, nullType, objType)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_notificationsEnabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_assignedGroup(ctx context.Context, field graphql.CollectedField, obj *model.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_assignedGroup(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.User().AssignedGroup(rctx, obj)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			nullType, err := ec.unmarshalNNullType2githubcomKAChallengeCouncilBemagraphmodelNullType(ctx, "NULL")
			if err != nil {
				return nil, err
			}
			if ec.directives.IsAuthenticated == nil {
				return nil, errors.New("directive isAuthenticated is not implemented")
			}
			return ec.directives.IsAuthenticated(ctx, obj, directive0, nullType)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			permission, err := ec.unmarshalNPermission2githubcomKAChallengeCouncilBemagraphmodelPermission(ctx, "VIEW_JUDGING_SETTINGS")
			if err != nil {
				return nil, err
			}
			nullType, err := ec.unmarshalNNullType2githubcomKAChallengeCouncilBemagraphmodelNullType(ctx, "NULL")
			if err != nil {
				return nil, err
			}
			objType, err := ec.unmarshalOObjectType2githubcomKAChallengeCouncilBemagraphmodelObjectType(ctx, "USER")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasPermission == nil {
				return nil, errors.New("directive hasPermission is not implemented")
			}
			return ec.directives.HasPermission(ctx, obj, directive1, permission, nullType, objType)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.JudgingGroup); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/KA-Challenge-Council/Bema/graph/model.JudgingGroup`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.JudgingGroup)
	fc.Result = res
	return ec.marshalOJudgingGroup2githubcomKAChallengeCouncilBemagraphmodelJudgingGroup(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_assignedGroup(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_JudgingGroup_id(ctx, field)
			case "name":
				return ec.fieldContext_JudgingGroup_name(ctx, field)
			case "isActive":
				return ec.fieldContext_JudgingGroup_isActive(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type JudgingGroup", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalN__DirectiveLocation2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_locations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __DirectiveLocation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_isRepeatable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRepeatable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_defaultValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_types(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_types(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_queryType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_queryType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_mutationType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_mutationType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_subscriptionType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_directives(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_directives(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Directive_name(ctx, field)
			case "description":
				return ec.fieldContext___Directive_description(ctx, field)
			case "locations":
				return ec.fieldContext___Directive_locations(ctx, field)
			case "args":
				return ec.fieldContext___Directive_args(ctx, field)
			case "isRepeatable":
				return ec.fieldContext___Directive_isRepeatable(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Directive", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_kind(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __TypeKind does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_fields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return ec.marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_fields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Field_name(ctx, field)
			case "description":
				return ec.fieldContext___Field_description(ctx, field)
			case "args":
				return ec.fieldContext___Field_args(ctx, field)
			case "type":
				return ec.fieldContext___Field_type(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___Field_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___Field_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Field", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_fields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_interfaces(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_interfaces(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_possibleTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_possibleTypes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_enumValues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return ec.marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_enumValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___EnumValue_name(ctx, field)
			case "description":
				return ec.fieldContext___EnumValue_description(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___EnumValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___EnumValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __EnumValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_enumValues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_inputFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_inputFields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_ofType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_ofType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_specifiedByURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpecifiedByURL(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var announcementImplementors = []string{"Announcement"}

func (ec *executionContext) _Announcement(ctx context.Context, sel ast.SelectionSet, obj *model.Announcement) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, announcementImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Announcement")
		case "id":

			out.Values[i] = ec._Announcement_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "author":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Announcement_author(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "created":

			out.Values[i] = ec._Announcement_created(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "title":

			out.Values[i] = ec._Announcement_title(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "content":

			out.Values[i] = ec._Announcement_content(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "isPublic":

			out.Values[i] = ec._Announcement_isPublic(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var contestImplementors = []string{"Contest"}

func (ec *executionContext) _Contest(ctx context.Context, sel ast.SelectionSet, obj *model.Contest) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, contestImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Contest")
		case "id":

			out.Values[i] = ec._Contest_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "name":

			out.Values[i] = ec._Contest_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "url":

			out.Values[i] = ec._Contest_url(ctx, field, obj)

		case "author":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Contest_author(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "badgeSlug":

			out.Values[i] = ec._Contest_badgeSlug(ctx, field, obj)

		case "badgeImageUrl":

			out.Values[i] = ec._Contest_badgeImageUrl(ctx, field, obj)

		case "isCurrent":

			out.Values[i] = ec._Contest_isCurrent(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "startDate":

			out.Values[i] = ec._Contest_startDate(ctx, field, obj)

		case "endDate":

			out.Values[i] = ec._Contest_endDate(ctx, field, obj)

		case "isVotingEnabled":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Contest_isVotingEnabled(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "winners":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Contest_winners(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var contestantImplementors = []string{"Contestant"}

func (ec *executionContext) _Contestant(ctx context.Context, sel ast.SelectionSet, obj *model.Contestant) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, contestantImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Contestant")
		case "kaid":

			out.Values[i] = ec._Contestant_kaid(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "name":

			out.Values[i] = ec._Contestant_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "entries":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Contestant_entries(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "entryCount":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Contestant_entryCount(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "contestCount":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Contestant_contestCount(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var entriesPerLevelImplementors = []string{"EntriesPerLevel"}

func (ec *executionContext) _EntriesPerLevel(ctx context.Context, sel ast.SelectionSet, obj *model.EntriesPerLevel) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, entriesPerLevelImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("EntriesPerLevel")
		case "level":

			out.Values[i] = ec._EntriesPerLevel_level(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "count":

			out.Values[i] = ec._EntriesPerLevel_count(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var entryImplementors = []string{"Entry"}

func (ec *executionContext) _Entry(ctx context.Context, sel ast.SelectionSet, obj *model.Entry) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, entryImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Entry")
		case "id":

			out.Values[i] = ec._Entry_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "contest":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Entry_contest(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "url":

			out.Values[i] = ec._Entry_url(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "kaid":

			out.Values[i] = ec._Entry_kaid(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "title":

			out.Values[i] = ec._Entry_title(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "author":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Entry_author(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "skillLevel":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Entry_skillLevel(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "votes":

			out.Values[i] = ec._Entry_votes(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "created":

			out.Values[i] = ec._Entry_created(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "height":

			out.Values[i] = ec._Entry_height(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "isWinner":

			out.Values[i] = ec._Entry_isWinner(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "group":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Entry_group(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "isFlagged":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Entry_isFlagged(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "isDisqualified":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Entry_isDisqualified(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "isSkillLevelLocked":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Entry_isSkillLevelLocked(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "averageScore":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Entry_averageScore(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "evaluationCount":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Entry_evaluationCount(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "voteCount":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Entry_voteCount(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "isVotedByUser":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Entry_isVotedByUser(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "judgeVotes":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Entry_judgeVotes(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var entryVoteImplementors = []string{"EntryVote"}

func (ec *executionContext) _EntryVote(ctx context.Context, sel ast.SelectionSet, obj *model.EntryVote) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, entryVoteImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("EntryVote")
		case "id":

			out.Values[i] = ec._EntryVote_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "user":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._EntryVote_user(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "reason":

			out.Values[i] = ec._EntryVote_reason(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var errorImplementors = []string{"Error"}

func (ec *executionContext) _Error(ctx context.Context, sel ast.SelectionSet, obj *model.Error) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, errorImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Error")
		case "id":

			out.Values[i] = ec._Error_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "message":

			out.Values[i] = ec._Error_message(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "stack":

			out.Values[i] = ec._Error_stack(ctx, field, obj)

		case "timestamp":

			out.Values[i] = ec._Error_timestamp(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "requestOrigin":

			out.Values[i] = ec._Error_requestOrigin(ctx, field, obj)

		case "requestReferrer":

			out.Values[i] = ec._Error_requestReferrer(ctx, field, obj)

		case "requestUserAgent":

			out.Values[i] = ec._Error_requestUserAgent(ctx, field, obj)

		case "user":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Error_user(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var fullUserProfileImplementors = []string{"FullUserProfile"}

func (ec *executionContext) _FullUserProfile(ctx context.Context, sel ast.SelectionSet, obj *model.FullUserProfile) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, fullUserProfileImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FullUserProfile")
		case "isAdmin":

			out.Values[i] = ec._FullUserProfile_isAdmin(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isImpersonated":

			out.Values[i] = ec._FullUserProfile_isImpersonated(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "loggedIn":

			out.Values[i] = ec._FullUserProfile_loggedIn(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "originKaid":

			out.Values[i] = ec._FullUserProfile_originKaid(ctx, field, obj)

		case "user":

			out.Values[i] = ec._FullUserProfile_user(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var judgingCriteriaImplementors = []string{"JudgingCriteria"}

func (ec *executionContext) _JudgingCriteria(ctx context.Context, sel ast.SelectionSet, obj *model.JudgingCriteria) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, judgingCriteriaImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("JudgingCriteria")
		case "id":

			out.Values[i] = ec._JudgingCriteria_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":

			out.Values[i] = ec._JudgingCriteria_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec._JudgingCriteria_description(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isActive":

			out.Values[i] = ec._JudgingCriteria_isActive(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "sortOrder":

			out.Values[i] = ec._JudgingCriteria_sortOrder(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var judgingGroupImplementors = []string{"JudgingGroup"}

func (ec *executionContext) _JudgingGroup(ctx context.Context, sel ast.SelectionSet, obj *model.JudgingGroup) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, judgingGroupImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("JudgingGroup")
		case "id":

			out.Values[i] = ec._JudgingGroup_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":

			out.Values[i] = ec._JudgingGroup_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isActive":

			out.Values[i] = ec._JudgingGroup_isActive(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var permissionsImplementors = []string{"Permissions"}

func (ec *executionContext) _Permissions(ctx context.Context, sel ast.SelectionSet, obj *model.Permissions) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, permissionsImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Permissions")
		case "add_entries":

			out.Values[i] = ec._Permissions_add_entries(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "add_users":

			out.Values[i] = ec._Permissions_add_users(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "assign_entry_groups":

			out.Values[i] = ec._Permissions_assign_entry_groups(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "assign_evaluator_groups":

			out.Values[i] = ec._Permissions_assign_evaluator_groups(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "assume_user_identities":

			out.Values[i] = ec._Permissions_assume_user_identities(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "change_user_passwords":

			out.Values[i] = ec._Permissions_change_user_passwords(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "delete_all_evaluations":

			out.Values[i] = ec._Permissions_delete_all_evaluations(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "delete_all_tasks":

			out.Values[i] = ec._Permissions_delete_all_tasks(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "delete_contests":

			out.Values[i] = ec._Permissions_delete_contests(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "delete_entries":

			out.Values[i] = ec._Permissions_delete_entries(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "delete_errors":

			out.Values[i] = ec._Permissions_delete_errors(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "delete_kb_content":

			out.Values[i] = ec._Permissions_delete_kb_content(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "edit_all_evaluations":

			out.Values[i] = ec._Permissions_edit_all_evaluations(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "edit_all_tasks":

			out.Values[i] = ec._Permissions_edit_all_tasks(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "edit_contests":

			out.Values[i] = ec._Permissions_edit_contests(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "edit_entries":

			out.Values[i] = ec._Permissions_edit_entries(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "edit_kb_content":

			out.Values[i] = ec._Permissions_edit_kb_content(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "edit_user_profiles":

			out.Values[i] = ec._Permissions_edit_user_profiles(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "judge_entries":

			out.Values[i] = ec._Permissions_judge_entries(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "manage_announcements":

			out.Values[i] = ec._Permissions_manage_announcements(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "manage_judging_criteria":

			out.Values[i] = ec._Permissions_manage_judging_criteria(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "manage_judging_groups":

			out.Values[i] = ec._Permissions_manage_judging_groups(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "manage_winners":

			out.Values[i] = ec._Permissions_manage_winners(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "publish_kb_content":

			out.Values[i] = ec._Permissions_publish_kb_content(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "view_admin_stats":

			out.Values[i] = ec._Permissions_view_admin_stats(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "view_all_evaluations":

			out.Values[i] = ec._Permissions_view_all_evaluations(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "view_all_tasks":

			out.Values[i] = ec._Permissions_view_all_tasks(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "view_all_users":

			out.Values[i] = ec._Permissions_view_all_users(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "view_errors":

			out.Values[i] = ec._Permissions_view_errors(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "view_judging_settings":

			out.Values[i] = ec._Permissions_view_judging_settings(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "announcements":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_announcements(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "contestant":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_contestant(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "contestantSearch":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_contestantSearch(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "contests":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_contests(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "contest":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_contest(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "currentContest":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_currentContest(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "entries":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_entries(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "entry":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_entry(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "flaggedEntries":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_flaggedEntries(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "entriesByAverageScore":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_entriesByAverageScore(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "entriesPerLevel":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_entriesPerLevel(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "errors":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_errors(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "error":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_error(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "allCriteria":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_allCriteria(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "activeCriteria":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_activeCriteria(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "allJudgingGroups":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_allJudgingGroups(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "activeJudgingGroups":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_activeJudgingGroups(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "judgingGroup":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_judgingGroup(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "tasks":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_tasks(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "completedTasks":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_completedTasks(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "availableTasks":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_availableTasks(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "currentUserTasks":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_currentUserTasks(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "currentUser":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_currentUser(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "users":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_users(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "inactiveUsers":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_inactiveUsers(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "user":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_user(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "__type":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___type(ctx, field)
			})

		case "__schema":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___schema(ctx, field)
			})

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var taskImplementors = []string{"Task"}

func (ec *executionContext) _Task(ctx context.Context, sel ast.SelectionSet, obj *model.Task) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Task")
		case "id":

			out.Values[i] = ec._Task_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "title":

			out.Values[i] = ec._Task_title(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "assignedUser":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_assignedUser(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "status":

			out.Values[i] = ec._Task_status(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "dueDate":

			out.Values[i] = ec._Task_dueDate(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var userImplementors = []string{"User"}

func (ec *executionContext) _User(ctx context.Context, sel ast.SelectionSet, obj *model.User) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("User")
		case "id":

			out.Values[i] = ec._User_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "kaid":

			out.Values[i] = ec._User_kaid(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "name":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_name(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "nickname":

			out.Values[i] = ec._User_nickname(ctx, field, obj)

		case "username":

			out.Values[i] = ec._User_username(ctx, field, obj)

		case "email":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_email(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "accountLocked":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_accountLocked(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "permissions":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_permissions(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "isAdmin":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_isAdmin(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "lastLogin":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_lastLogin(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "termStart":

			out.Values[i] = ec._User_termStart(ctx, field, obj)

		case "termEnd":

			out.Values[i] = ec._User_termEnd(ctx, field, obj)

		case "notificationsEnabled":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_notificationsEnabled(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "assignedGroup":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_assignedGroup(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":

			out.Values[i] = ec.___Directive_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___Directive_description(ctx, field, obj)

		case "locations":

			out.Values[i] = ec.___Directive_locations(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "args":

			out.Values[i] = ec.___Directive_args(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isRepeatable":

			out.Values[i] = ec.___Directive_isRepeatable(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":

			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)

		case "isDeprecated":

			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":

			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":

			out.Values[i] = ec.___Field_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___Field_description(ctx, field, obj)

		case "args":

			out.Values[i] = ec.___Field_args(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "type":

			out.Values[i] = ec.___Field_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isDeprecated":

			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":

			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":

			out.Values[i] = ec.___InputValue_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___InputValue_description(ctx, field, obj)

		case "type":

			out.Values[i] = ec.___InputValue_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "defaultValue":

			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "description":

			out.Values[i] = ec.___Schema_description(ctx, field, obj)

		case "types":

			out.Values[i] = ec.___Schema_types(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "queryType":

			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "mutationType":

			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)

		case "subscriptionType":

			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)

		case "directives":

			out.Values[i] = ec.___Schema_directives(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":

			out.Values[i] = ec.___Type_kind(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":

			out.Values[i] = ec.___Type_name(ctx, field, obj)

		case "description":

			out.Values[i] = ec.___Type_description(ctx, field, obj)

		case "fields":

			out.Values[i] = ec.___Type_fields(ctx, field, obj)

		case "interfaces":

			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)

		case "possibleTypes":

			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)

		case "enumValues":

			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)

		case "inputFields":

			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)

		case "ofType":

			out.Values[i] = ec.___Type_ofType(ctx, field, obj)

		case "specifiedByURL":

			out.Values[i] = ec.___Type_specifiedByURL(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) marshalNAnnouncement2githubcomKAChallengeCouncilBemagraphmodelAnnouncement(ctx context.Context, sel ast.SelectionSet, v []*model.Announcement) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAnnouncement2githubcomKAChallengeCouncilBemagraphmodelAnnouncement(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNAnnouncement2githubcomKAChallengeCouncilBemagraphmodelAnnouncement(ctx context.Context, sel ast.SelectionSet, v *model.Announcement) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Announcement(ctx, sel, v)
}

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNContest2githubcomKAChallengeCouncilBemagraphmodelContest(ctx context.Context, sel ast.SelectionSet, v model.Contest) graphql.Marshaler {
	return ec._Contest(ctx, sel, &v)
}

func (ec *executionContext) marshalNContest2githubcomKAChallengeCouncilBemagraphmodelContest(ctx context.Context, sel ast.SelectionSet, v []*model.Contest) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNContest2githubcomKAChallengeCouncilBemagraphmodelContest(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNContest2githubcomKAChallengeCouncilBemagraphmodelContest(ctx context.Context, sel ast.SelectionSet, v *model.Contest) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Contest(ctx, sel, v)
}

func (ec *executionContext) marshalNContestant2githubcomKAChallengeCouncilBemagraphmodelContestant(ctx context.Context, sel ast.SelectionSet, v model.Contestant) graphql.Marshaler {
	return ec._Contestant(ctx, sel, &v)
}

func (ec *executionContext) marshalNContestant2githubcomKAChallengeCouncilBemagraphmodelContestant(ctx context.Context, sel ast.SelectionSet, v []*model.Contestant) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNContestant2githubcomKAChallengeCouncilBemagraphmodelContestant(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNContestant2githubcomKAChallengeCouncilBemagraphmodelContestant(ctx context.Context, sel ast.SelectionSet, v *model.Contestant) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Contestant(ctx, sel, v)
}

func (ec *executionContext) marshalNEntriesPerLevel2githubcomKAChallengeCouncilBemagraphmodelEntriesPerLevel(ctx context.Context, sel ast.SelectionSet, v []*model.EntriesPerLevel) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNEntriesPerLevel2githubcomKAChallengeCouncilBemagraphmodelEntriesPerLevel(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNEntriesPerLevel2githubcomKAChallengeCouncilBemagraphmodelEntriesPerLevel(ctx context.Context, sel ast.SelectionSet, v *model.EntriesPerLevel) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._EntriesPerLevel(ctx, sel, v)
}

func (ec *executionContext) marshalNEntry2githubcomKAChallengeCouncilBemagraphmodelEntry(ctx context.Context, sel ast.SelectionSet, v []*model.Entry) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNEntry2githubcomKAChallengeCouncilBemagraphmodelEntry(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNEntry2githubcomKAChallengeCouncilBemagraphmodelEntry(ctx context.Context, sel ast.SelectionSet, v *model.Entry) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Entry(ctx, sel, v)
}

func (ec *executionContext) marshalNEntryVote2githubcomKAChallengeCouncilBemagraphmodelEntryVote(ctx context.Context, sel ast.SelectionSet, v []*model.EntryVote) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNEntryVote2githubcomKAChallengeCouncilBemagraphmodelEntryVote(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNEntryVote2githubcomKAChallengeCouncilBemagraphmodelEntryVote(ctx context.Context, sel ast.SelectionSet, v *model.EntryVote) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._EntryVote(ctx, sel, v)
}

func (ec *executionContext) marshalNError2githubcomKAChallengeCouncilBemagraphmodelError(ctx context.Context, sel ast.SelectionSet, v []*model.Error) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNError2githubcomKAChallengeCouncilBemagraphmodelError(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNError2githubcomKAChallengeCouncilBemagraphmodelError(ctx context.Context, sel ast.SelectionSet, v *model.Error) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Error(ctx, sel, v)
}

func (ec *executionContext) marshalNFullUserProfile2githubcomKAChallengeCouncilBemagraphmodelFullUserProfile(ctx context.Context, sel ast.SelectionSet, v model.FullUserProfile) graphql.Marshaler {
	return ec._FullUserProfile(ctx, sel, &v)
}

func (ec *executionContext) marshalNFullUserProfile2githubcomKAChallengeCouncilBemagraphmodelFullUserProfile(ctx context.Context, sel ast.SelectionSet, v *model.FullUserProfile) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._FullUserProfile(ctx, sel, v)
}

func (ec *executionContext) unmarshalNID2int(ctx context.Context, v interface{}) (int, error) {
	res, err := graphql.UnmarshalIntID(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNID2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalIntID(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v interface{}) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNJudgingCriteria2githubcomKAChallengeCouncilBemagraphmodelJudgingCriteria(ctx context.Context, sel ast.SelectionSet, v []*model.JudgingCriteria) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNJudgingCriteria2githubcomKAChallengeCouncilBemagraphmodelJudgingCriteria(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNJudgingCriteria2githubcomKAChallengeCouncilBemagraphmodelJudgingCriteria(ctx context.Context, sel ast.SelectionSet, v *model.JudgingCriteria) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._JudgingCriteria(ctx, sel, v)
}

func (ec *executionContext) marshalNJudgingGroup2githubcomKAChallengeCouncilBemagraphmodelJudgingGroup(ctx context.Context, sel ast.SelectionSet, v []*model.JudgingGroup) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNJudgingGroup2githubcomKAChallengeCouncilBemagraphmodelJudgingGroup(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNJudgingGroup2githubcomKAChallengeCouncilBemagraphmodelJudgingGroup(ctx context.Context, sel ast.SelectionSet, v *model.JudgingGroup) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._JudgingGroup(ctx, sel, v)
}

func (ec *executionContext) unmarshalNNullType2githubcomKAChallengeCouncilBemagraphmodelNullType(ctx context.Context, v interface{}) (model.NullType, error) {
	var res model.NullType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNNullType2githubcomKAChallengeCouncilBemagraphmodelNullType(ctx context.Context, sel ast.SelectionSet, v model.NullType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNPermission2githubcomKAChallengeCouncilBemagraphmodelPermission(ctx context.Context, v interface{}) (model.Permission, error) {
	var res model.Permission
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNPermission2githubcomKAChallengeCouncilBemagraphmodelPermission(ctx context.Context, sel ast.SelectionSet, v model.Permission) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNTask2githubcomKAChallengeCouncilBemagraphmodelTask(ctx context.Context, sel ast.SelectionSet, v []*model.Task) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTask2githubcomKAChallengeCouncilBemagraphmodelTask(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTask2githubcomKAChallengeCouncilBemagraphmodelTask(ctx context.Context, sel ast.SelectionSet, v *model.Task) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Task(ctx, sel, v)
}

func (ec *executionContext) marshalNUser2githubcomKAChallengeCouncilBemagraphmodelUser(ctx context.Context, sel ast.SelectionSet, v model.User) graphql.Marshaler {
	return ec._User(ctx, sel, &v)
}

func (ec *executionContext) marshalNUser2githubcomKAChallengeCouncilBemagraphmodelUser(ctx context.Context, sel ast.SelectionSet, v []*model.User) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUser2githubcomKAChallengeCouncilBemagraphmodelUser(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNUser2githubcomKAChallengeCouncilBemagraphmodelUser(ctx context.Context, sel ast.SelectionSet, v *model.User) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._User(ctx, sel, v)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	return res
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalBoolean(*v)
	return res
}

func (ec *executionContext) marshalOContest2githubcomKAChallengeCouncilBemagraphmodelContest(ctx context.Context, sel ast.SelectionSet, v *model.Contest) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Contest(ctx, sel, v)
}

func (ec *executionContext) marshalOContestant2githubcomKAChallengeCouncilBemagraphmodelContestant(ctx context.Context, sel ast.SelectionSet, v *model.Contestant) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Contestant(ctx, sel, v)
}

func (ec *executionContext) marshalOEntry2githubcomKAChallengeCouncilBemagraphmodelEntry(ctx context.Context, sel ast.SelectionSet, v []*model.Entry) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNEntry2githubcomKAChallengeCouncilBemagraphmodelEntry(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOEntry2githubcomKAChallengeCouncilBemagraphmodelEntry(ctx context.Context, sel ast.SelectionSet, v *model.Entry) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Entry(ctx, sel, v)
}

func (ec *executionContext) marshalOError2githubcomKAChallengeCouncilBemagraphmodelError(ctx context.Context, sel ast.SelectionSet, v *model.Error) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Error(ctx, sel, v)
}

func (ec *executionContext) unmarshalOFloat2float64(ctx context.Context, v interface{}) (*float64, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalFloatContext(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFloat2float64(ctx context.Context, sel ast.SelectionSet, v *float64) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalFloatContext(*v)
	return graphql.WrapContextMarshaler(ctx, res)
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v interface{}) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalInt(*v)
	return res
}

func (ec *executionContext) marshalOJudgingGroup2githubcomKAChallengeCouncilBemagraphmodelJudgingGroup(ctx context.Context, sel ast.SelectionSet, v *model.JudgingGroup) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._JudgingGroup(ctx, sel, v)
}

func (ec *executionContext) unmarshalOObjectType2githubcomKAChallengeCouncilBemagraphmodelObjectType(ctx context.Context, v interface{}) (*model.ObjectType, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.ObjectType)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOObjectType2githubcomKAChallengeCouncilBemagraphmodelObjectType(ctx context.Context, sel ast.SelectionSet, v *model.ObjectType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOPermissions2githubcomKAChallengeCouncilBemagraphmodelPermissions(ctx context.Context, sel ast.SelectionSet, v *model.Permissions) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Permissions(ctx, sel, v)
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) marshalOUser2githubcomKAChallengeCouncilBemagraphmodelUser(ctx context.Context, sel ast.SelectionSet, v *model.User) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._User(ctx, sel, v)
}

func (ec *executionContext) marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
